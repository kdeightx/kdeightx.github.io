[{"title":"字符串","date":"2021-03-11T02:53:36.528Z","path":"2021/03/11/C语言第九课/","text":"C语言第九课（接第六课）C语言标准常用的编译器有MSVC、GCC、CLANG。 现在的C标准有C89、C99、C11、C17、C23 标准的不同比如用C89的VC6里面定义变量必须再最前面定义 123456789101112131415161718192021222324252627282930313233343536373839//VC里面（用的是C89）int main()&#123; int a = 0; ===============&gt;定义变量必须在前面 for(a = 0;a &lt; 10;a++) &#123; //..... &#125; for(int b = 0;b &lt; 10;b++)====&gt;这里定义编译就无法通过 &#123; //..... &#125;&#125;//想要在VC里面后面定义需要一个小技巧，就是加一个作用域int main()&#123; int a = 0; for(a = 0;a &lt; 10;a++) &#123; //..... &#125; &#123;================&gt;加上这个作用域就可以在后面定义了 int b; ======&gt;此时就可以编译通过 &#125;&#125;//VS2013int main()&#123; int a = 0; for(a = 0;a &lt; 10;a++) &#123; //..... &#125; for(int b = 0;b &lt; 10;b++)====&gt;这里定义编译正常通过 &#123; //..... &#125;&#125; 最早的是C89。C17修复了C11的一些bug。C23目前还不清楚有哪些编译器使用，以后可能会有吧。 另外就是，C标准更新很慢，不像别的，包括C++。 查看C标准的网站是：https://en.cppreference.com/w/ 编译器和C标准不一定相同 编译器和vs这种集成开发环境是两个东西，虽然编译器是根据C标准来写的，但不同的编译器作者写的编译器依旧有不同。比如微软写的MSVC编译器里面不允许在定义数组的时候用变量来表示数组下标。 12int count = 10;int ary[count] = &#123;0&#125;;===========&gt;//这种定义数组的方法C标准允许，但微软不允许，微软给出的解释就是容易出现bug或漏洞。 通过stdint.h这个头文件来固定变量大小，这样就可以使代码在不同编译器环境下依旧可以使用，实现跨版本跨平台使用。 ASCII编码表一个字节有8位，一般用7位表示，第八位是符号位。 也就是可以表示0~127个数。 不同的国家和公司写自己的ASCII扩展这就导致了在不同的系统上显示不同的效果。 后来为了解决例如汉字等别的语言问题，就提出了多字节字符集(MBCS) 中国做了一个标准GB2312 。后面扩展的就叫GBKXXX 两个字符表示一个汉字。 为了解决不同国家需要不同的字符表，微软做了一个·Code Page·，这个代码页几乎包含了所有国家的字符代码。需要时选择自己国家的代码即可。 后面又出现了万国编码：Unicode编码。 Unicode字符集包含所有国家的字符代码。 但Unicode字符集有不好的地方，就是将所有国家的字符都用两个字节表示一个字符，例如中国的汉字，两个字符表示一个汉字，包括英文也是。对于英文这种只需要一个字符就可以表示，却在Unicode里用两个表示，这样极大的浪费了空间。 现在用的最多的是UTF-8编码 宽字节就是用Unicode编码显示的字符。 注意：代码所用的字符编码要和文件字符编码一直，不然会出现乱码。 字符串一连串的字符数组就是字符串， Pascal字符串：先在前面表示字符串长度，后面接字符串内容。 C语言里不是这样，为了让计算机知道字符串结尾的位置，会在后面自动补一个0。 如果是用宽字符（Unicode）来写，会在后面自动补两个0。 12char string1[] = &#123;&quot;hello&quot;&#125;;===========&gt;后面自动补一个0wchar_t string2[5] = &#123;L&quot;hello&quot;&#125;;======&gt;这个wchar_t和L表示Unicode编码。后面自动补两个0","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C标准","slug":"C标准","permalink":"http://example.com/tags/C%E6%A0%87%E5%87%86/"},{"name":"cppreference.com","slug":"cppreference-com","permalink":"http://example.com/tags/cppreference-com/"},{"name":"宽字符","slug":"宽字符","permalink":"http://example.com/tags/%E5%AE%BD%E5%AD%97%E7%AC%A6/"},{"name":"编译器","slug":"编译器","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"ASCII编码表","slug":"ASCII编码表","permalink":"http://example.com/tags/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/"}]},{"title":"数组","date":"2021-03-08T02:37:30.136Z","path":"2021/03/08/C语言第六课/","text":"C语言第六课数组数组的由来、定义及初始化 数组的由来 数组是用来存储多个（有限）相同类型数据的集合，组成数组的各个变量称为数组元素，数组元素也是一种变量。为了区分数组的各个元素，给数组进行了编号，也称为下标。 数组定义 数组的定义：数组类型说明符 数组名[数组元素个数]，数组元素个数只能是常量或常量表达式。 数组元素的引用方式：数组名[下标]。 数组初始化 12int Array[5] = &#123;1,2,3,4,5&#125;;int Array[5] = &#123;0&#125;; 数组的传参 数组传参 例如： 1234567891011void fun(int anArray[]) //anArray[]这个数组是临时创建的数组变量，不是下面的数组变量，变量名可以不同&#123; //... int n = 0;&#125;void main()&#123; int anArray[5] = &#123;1,2,3,4,5&#125;; fun(anArray);//传递数组首地址 fun(&amp;anArray[2]);//传递下标为2的元素的地址&#125; 冒泡、选择排序和查找 冒泡排序 两个相邻的元素依次比较，如果从小到大排序，第一个值如果比第二个值大则进行交换，以此类推。最大值则会依次沉入数组最后面，最小值则会慢慢排到数组最前面。如果从大到小排序，条件相反，第一个值如果比第二个值小则进行交换。 1234567891011121314int anArray[6] = &#123;8,5,4,2,6,7&#125;; //5,8,4,2,6,7 //5,4,8,2,6,7 //5,4,2,8,6,7 //5,4,2,6,8,7 //5,4,2,6,7,8 //4,5,2,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //2,4,5,6,7,8 //冒泡排序就是这样，anArray[i]与anArray[i + 1]向下依次比较，//大的值放在右侧，小的值放在左侧，依次下去。 1234567891011121314151617int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;;int temp = 0, num = 0;num = sizeof(anArray) / sizeof(int);printf(&quot;%d&quot;, num);for (int i = 0; i &lt; num - 1; i++) &#123; for (int j = 0; j &lt; num - 1; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; 选择排序 两个相邻的值进行比较，如果从小到大排序，如果第一个值比第二个值大，则记录较小值的下标，第二次比较，较小值和后续的值进行比较，始终记录较小值的下标，一轮比较完毕，记录的较小值和下标为0的元素进行交换，第二轮则和下标为1的元素交换。依次类推。 1234567891011int anArray[6] = &#123;8,5,4,2,6,7&#125;; //2,5,4,8,6,7 //2,4,5,8,6,7 //2,4,5,8,6,7 //2,4,5,6,8,7 //2,4,5,6,7,8 //选择排序就是这样，默认anArray[0]为最小值，//后面依次用anArray[0]这个变量的值与后面别的下标变量的值进行比较，//如果中间出现比默认的变量值小，则将它倆进行交换，//这样始终保证默认的最小下标变量都是真正拥有最小值的变量，//此时一轮结束，下一轮时将默认变量改为anArray[i + 1]，然后继续向后比较交换。 123456789101112131415161718192021222324int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;;int temp = 0, num = 0;num = sizeof(anArray) / sizeof(int);printf(&quot;%d&quot;, num);int Max = 0; for (int i = 0; i &lt; num - 1; i++) &#123; Max = i; //默认的最大变量为第一项0 for (int j = i; j &lt; num; j++) &#123; if (anArray[Max] &lt; anArray[j + 1])//用默认的最大变量的值比较下一项变量的值 &#123; Max = j + 1; //将最大的变量的下标赋给Max &#125; if (j == num - 1) //确认一轮都比较完毕 &#123; int temp = 0; //开始进行交换 temp = anArray[Max]; anArray[Max] = anArray[i]; anArray[i] = temp; &#125; &#125; &#125; 二分查找法 二分查找也叫折半查找，折半查找要求线性且顺序存储结构。 记录最小值的下标为左值，记录最大值的下标为右值，最小值的下标加上最大值的下标除以2得到中间值下标，如果中间值比查找值大则右值下标更新为中间值下标-1，如果中间值比查找值小则左值下标更新为中间值下标+1。如果中间值和查找值相等则表示找到了，否则依次类推，直到找完也找不到为止，当左值等于右值时，所有元素查找完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192首先需要数组内的所有元素值按从大到小或从小到大排列好，然后才能使用二分查找法 int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;; int temp = 0, num = 0; num = sizeof(anArray) / sizeof(int); printf(&quot;%d&quot;, num); //冒泡排序，简单点的 for (int i = 0; i &lt; num - 1; i++) &#123; for (int j = 0; j &lt; num - 1; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; //冒泡排序，稍微复杂点的 for (int i = 1; i &lt; num; i++) &#123; for (int j = 0; j &lt; num - i; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; //下面是二分查找法 int Max = 0; int Min = 0; int Mid = 0; int Find = 0; printf(&quot;输入要查找的值\\r\\n&quot;); scanf(&quot;%d&quot;, &amp;Find); Max = num; Min = 0; //第一种二分法 for (int i = 0; i &lt; (Min + Max) / 2; i++) &#123; Mid = (Max + Min) / 2; if (anArray[Min] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (anArray[Max] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (anArray[Mid] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (Max == Min + 1 &amp;&amp; (anArray[Max] != Find || anArray[Min] != Find)) &#123; printf(&quot;你要查找的数不存在\\r\\n&quot;); break; &#125; else if (anArray[Mid] &gt; Find) &#123; Max = Mid - 1; &#125; else if (anArray[Mid] &lt; Find) &#123; Min = Mid + 1; &#125; &#125; //第二种二分法 while (Min &lt;= Max) &#123; Mid = (Max + Min) / 2; if (anArray[Mid] &gt; Find) &#123; Max = Mid - 1; &#125; else if (anArray[Mid] &lt; Find) &#123; Min = Mid + 1; &#125; if (anArray[Mid] == Find) &#123; printf(&quot;你要找的%d在下标为%d的数组元素内\\r\\n&quot;, Find, Mid); &#125; else if (Min == Max &amp;&amp; (Mid != Find) || Min &gt; Max) &#123; printf(&quot;你输入的数不存在\\r\\n&quot;); &#125; &#125; 二维数组的定义及初始化 以数组为数组元素的数组，数组的数组。二维数组又称矩阵 12array[3][5] = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125;&#125;;数组名 行 列 = 初始化数组。。。 当一维数组元素过多，并且元素之间有集合关系时可以用二维数组的方式存储，不仅易于维护，而且定位起来也容易很多。 12345array[3][5] = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125; =======&gt;注意最后可以加逗号，但仅限于高版本的编译器，VC就不能加&#125; 二维数组在内存中的存储和一维一样，依旧是连续存储，只是给程序员看的时候更加方便。 在用函数封装二维数组时，形参一定要有列数，但可以不用它。这是为了让编译器通过。 1234void RemoveRoom(char RoomAry[][3],int nRow,int nCol)========&gt;这里的3是为了让编译器通过，实际的行列用单独的变量来传&#123; //....&#125;","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"冒泡","slug":"冒泡","permalink":"http://example.com/tags/%E5%86%92%E6%B3%A1/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"函数","date":"2021-03-05T01:55:36.687Z","path":"2021/03/05/C语言第五课/","text":"C语言第五课函数函数的由来早期编写代码的时候人们发现只有遇到跳转指令之后才会跳转到目的指令处继续执行。所有代码都是按照将要执行的顺序排列，人们发现这样写代码非常费劲且容易出错，因为经常编写同样的代码导致工作量大幅度增加还浪费空间。为了节省空间和提高工作效率，于是想出了将经常使用的功能性代码提出来单独封装，并留出接口和外界通信。被封装的代码就是函数。 优点节省空间，对代码编写者阅读性大大提高，可维护性就变强了。 缺点性能慢，用时间换空间。在调用函数的时候，不如函数在main里面来的快，因为这中间的过程对计算机来说做了备份等工作。自然时间上就花了更多。 主函数、库函数、自定义函数主函数主函数是可执行程序的入口函数。当操作系统加载可执行程序到内存中，并且为可执行程序开辟进程空间后，系统调用的可执行程序内的第一个函数。 main()函数是C语言中的主函数，一个C程序有且仅有一个main()函数。 注意：其实真正的函数入口不是main()，只不过main()函数在用户界面看时是入口而已，系统内部不是。 库函数库函数是指把一些常用的函数单独封装到库文件/头文件里供人调用。调用时要用#include&lt;文件名.h&gt;包含调用函数所在的库文件/头文件 自定义函数自定义函数是指用户自己按需要编写的函数。调用时需要用#include“文件名.h”包含调用函数所在的头文件。 函数的定义等基本语法 函数的定义 返回值 函数名（参数类型 参数1，参数类型 参数2） 括号内可以不传参数，根据需要选择是否传参。 另外如果没有返回值可选择void这种类型 函数声明 1int MyFun(int nNum1,int nNum2); 函数实现 1234int MyFun(int nNum1,int nNum2)&#123; ...//代码&#125; 形参和实参 形参：定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。 实参：调用时传递给函数的参数，实参可以是常量，变量，表达式，函数等，在进行函数调用时，实参必须具有确定值。 实参传递给形参的数值是拷贝过去的值，不会影响到原参数。 想要实现自定义函数和主函数文件分开保存可以 1、新建一个包含自定义函数代码实现功能的.c源文件，这个文件里写自定义函数的实现过程。 2、新建一个包含自定义函数声明代码的.h头文件，这个文件里写自定义函数的函数声明。 3、在有主函数main()的.c源文件里用#include “文件名.h”包含上面这个自定义函数声明代码的.h头文件名。 这样自定义函数的实现代码就和主函数分开了，需要转移到别的主函数文件时，只需要将自定义函数的.c和.h两个文件加入即可。 命名 命名 为了统一编码风格及提高代码可读性，所以约定对变量名、函数名等采用统一风格的命名。 匈牙利命名法 微软采用的一种编码时命名规范，其基本原则： 12变量名&#x3D;属性+类型+对象描述 int nNumber &#x3D; 0; 对象的名称要求有明确的含义。据说这种命名法是一位匈牙利程序员发明的。 驼峰命名法 大驼峰 1int MyFun &#x3D; 0; &#x3D;&#x3D;&#x3D;&gt;第一个单词首字母大写，后一个单词首字母大写 小驼峰 1int myFun &#x3D; 0; &#x3D;&#x3D;&#x3D;&gt;第一个单词首字母小写，后一个单词首字母大写 递归 函数直接或间接调用函数本身，则该函数被称为递归函数。 123456789void MyFun()&#123; //... if(...) &#123; MyFun(); &#125; //...&#125; 1234567891011121314151617181920212223242526272829303132333435363738递归的运用比如目录的结构就是。​&#96;&#96;&#96;c#include &lt;stdio.h&gt;int MyAddFun(int);int mian()&#123; int nRet &#x3D; 0; nRet &#x3D; MyAddFun(5); &#x3D;&#x3D;&#x3D;&#x3D;&gt;调用函数并将结果存放到变量nRet里面 printf(&quot;%d\\r\\n&quot;,nRet);&#125;int MyAddFun(int nNum)&#123; int Temp &#x3D; 0; &#x3D;&#x3D;&#x3D;&#x3D;&gt;用来存放递归结果 if(nNum &#x3D;&#x3D; 1) &#123; return 1; &#x3D;&#x3D;&#x3D;&#x3D;&gt;给递归一个结束的返回值 &#125; Temp &#x3D; nNum + MyAddFun(nNum - 1); &#x3D;&#x3D;&#x3D;&gt;递归核心，实现不断自我调用 return Temp;&#125;&#x2F;&#x2F; 5 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + 2 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + 2 + 1 &#x3D;&#x3D;&#x3D;&gt;由于此时MyAddFun(nNum - 1)中(nNum - 1)结果为1，触发if判断执行return 1。&#x2F;&#x2F; MyAddFun（nNum - 1）&#x3D;&#x3D; 1；&#x2F;&#x2F;再往后一步一步往回走，结果就出来了。&#x2F;&#x2F;MyAddFun(5)&#x2F;&#x2F;5 + MyAddFun(4)&#x2F;&#x2F;4 + MyAddFun(3)&#x2F;&#x2F;3 + MyAddFun(2)&#x2F;&#x2F;2 + MyAddFun(1)&#x2F;&#x2F;1 补充在调试代码的时候，将变量放到监视窗口后，可以通过在变量前加上&amp;取地址符获取该变量在内存中的位置。通过这种方法查看内存数据。 123456int nNumber &#x3D; 10;&amp;nNumber &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;假定nNumber在内存中的地址为0X0019FF28因为是int型占四个字节所以它在内存中的数据为 0 A 0 0 0 0 0 0读法是顺序是 7-&gt;8 5-&gt;6 3-&gt;4 1-&gt;2十进制的10在内存中以十六进制A显示","categories":[],"tags":[{"name":"递归","slug":"递归","permalink":"http://example.com/tags/%E9%80%92%E5%BD%92/"},{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"},{"name":"命名法","slug":"命名法","permalink":"http://example.com/tags/%E5%91%BD%E5%90%8D%E6%B3%95/"}]},{"title":"分支与循环","date":"2021-03-04T14:52:03.230Z","path":"2021/03/04/C语音第四课/","text":"C语言第四课分支与循环运算符 siezeof 运算符 sizeof 算术运算符 1+ - * &#x2F; % ++ -- 关系运算符 123&#x3D;&#x3D; 与 !&#x3D; 等于 和 不等于&gt; 与 &lt; 大于 和 小于&gt;&#x3D;与&lt;&#x3D; 大于等于 和 小于等于 逻辑运算符 1&amp;&amp; 与 || 与 ! 逻辑与 和 逻辑或 和 逻辑非 条件运算符 1?:三元运算符 if…else分支结构12345678if(表达式) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;判断是否成立&#123; 语句一 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;成立时执行这里的语句&#125;else&#123; 语句二 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;不成立时执行这里的语句&#125; ​ switch…case分支结构- switch(开关语句)常和case、break、default一起用。实现多重分支 12345678910111213switch(整形表达式) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;整形表达式里的数值决定跳转到下面的数值几语句&#123; case 数值1: 语句1; break; case 数值2: 语句2; break; default: 语句n; break; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;跳出switch &#125; for、while、do…while循环结构- for循环由循环体和判断条件两个部分组成 12345678for(表达式1;条件;表达式2)&#123; 循环体语句&#125;for(int i &#x3D; 0; i &lt; length ; i++)&#123; ....;&#125; 执行过程： - 第一步：执行表达式1 - 第二步：判断条件 - 第三步：条件成立则执行语句和表达式2 - 第四步：重复执行二、三步 直到条件不成立结束循环。 while循环，满足条件时进入循环，当条件不满足时，跳出循环。 1234while(条件)&#123; 语句;&#125; 执行过程： 第一步：判断条件 第二步：条件成立则执行语句 第三步：重复执行一、二步 ​ 直到条件不成立结束循环。","categories":[],"tags":[{"name":"循环结构","slug":"循环结构","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"},{"name":"运算符","slug":"运算符","permalink":"http://example.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"输入输出、数据类型","date":"2021-03-03T02:12:54.185Z","path":"2021/03/03/C语言第三课/","text":"C语言第三课C语言简史 1950年欧美计算机学家合力推出了ALGOL算法语言 1958年ACM小组（美国计算机协会）和联邦德国的应用数学和力学协会（GAMM）在苏黎世把他们关于算法表示法的建议综合为一种编程语言，命名为IAL，后改为AIGOL58。 1960年图灵奖获得者艾伦佩利（Alan J.Perlis）发表了“算法语言Algol 60报告”，确定了程序设计语言ALGOL 60。 1963年英国剑桥大学推出了基于ALGOL 60的高级语言CPL语言。 1967年英国剑桥大学对CPL语言做了简化，推出了BCPL语言。 1970年美国贝尔实验室的肯-汤普森（Ken Thompson）以BCPL语言为基础推出了B语言（取BCPL的第一个字母）。并用B语言编写了第一个UNIX操作系统。 1972年贝尔实验室的丹尼斯-里奇（D.M.Ritchie）在B语言的基础上设计出了C语言。丹尼斯-里奇（D.M.Ritchie）和肯-汤普森（Ken Thompson）用C语言重写了UNIX系统。 IDEIDE集成开发环境，用于提供程序开发环境的应用程序。一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。 创建第一个程序stdio===&gt;standard input &amp; output===&gt;标准输入输出 1234567#include &lt;stdio.h&gt;int main(int argc,char* argv[])&#123; printf(&quot;hello word!&quot;); return 0;&#125; Main函数C语言的入口函数main任何C语言程序只能有一个main函数，被称为主函数。 main函数的参数C语言标准中，main的参数有两个，一个十int类型的argc，一个是char*数组的argv。它们对应的是命令行传来的命令行传来的命令行参数。windows命令行通过echo &amp;errorLeveI%命令可以获取到return返回值。 argc该变量是用来统计argv数组里参数的数量。 MSDN、输入输出 MSDN 微软提供的一种信息服务 介绍各种编程技巧 printf 格式化输出函数，向标准输出设备按规定格式输出。 函数原型 1int printf(const char *format[,argument]...); scanf 从标准输入流中读取格式化数据。 函数原型 1int scanf(const char *format[,argument]...); 数据类型 数据类型 byte/char、short、int、long、longlong、float、double、signed、unsigned 1字节、2字节、4字节、4字节、8字节、4字节、8字节。 int和long的区别 早期的操作系统是16位，int用2字节表示，long用4字节表示。 发展到32位操作系统，int用4字节表示，与long相同。","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://example.com/tags/IDE/"},{"name":"数据类型","slug":"数据类型","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"进制","date":"2021-03-02T02:02:00.610Z","path":"2021/03/02/C语言第二课/","text":"C语言第二课进制 [toc] 二进制（0～1）进位规则：逢二进一。 00=&gt;01=&gt;10=&gt;11=&gt;…… 三个二进制数可以表示一个八进制数。四个二进制数可以表示一个十六进制数。另外，一个字节是8bit位，这就是为什么计算机用十六进制数表示数据。 12010 101 &#x3D;&#x3D;&#x3D;&gt;二进制数，三位可以表示一个八进制数 2 4+1 &#x3D;&#x3D;&#x3D;&gt;八进制数25 二进制数在代码中加0b，例如0b10。 八进制（0～7）进位规则：逢八进一。 八进制加0,是零，不是O，例如010； 十进制（0～7）进位规则：逢十进一。 0=&gt;1=&gt;2=&gt;3=&gt;……=&gt;06=&gt;07=&gt;10=&gt;11=&gt;…… 十六进制（0～F）进位规则：01=&gt;02=&gt; …… =&gt;09=&gt;0A=&gt;0B=&gt; …… =&gt;0F=&gt;10…… 十六进制0xA。 借位规则：二进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当2，变成020，现在的个位为0，依旧不够减1，继续借，012，个位的2够减1，那么012 - 1 = 011，所以100 - 1 = 011。 借位规则：八进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当8，变成080，现在的个位为0，依旧不够减1，继续借，078，个位的8够减1，那么078 - 1 = 077，所以100 - 1 = 077。 借位规则：十进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当10，变成0A（这里的10用十进制A表示）0，现在的个位为0，依旧不够减1，继续借，09A，个位的A够减1，那么09A - 1 = 099，所以100 - 1 = 099。 借位规则：十六进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当16，变成0G（这里的16用十七进制G表示）0，现在的个位为0，依旧不够减1，继续借，0FG，个位的G够减1，那么0FG - 1 = 0FF，所以100 - 1 = 0FF。 规律总结12345678910111213141111 &#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制数8421 &#x3D;&#x3D;&#x3D;&#x3D;&gt;1000 &#x3D; 8 , 100 &#x3D; 4 ， 10 &#x3D; 2 ， 1 &#x3D; 1。8 + 4 + 2 + 1 &#x3D;15 &#x3D;&#x3D;&#x3D;&gt;这是二进制1111表示为十进制时候的数值。通过上面这个可以发现四位的二进制数刚好可以表示一个十六进制个位数：1 + 2 + 4 + 8 &#x3D;&gt; 15例如：1 1 1 1 116 8 4 2 1 2^4 + 2^3 + 2^2 + 2^1 + 2^0 &#x3D;31 &#x3D;&#x3D;&#x3D;&gt;这个二进制11111表示为十进制时候的数值。1111 1111 &#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制数 F F &#x3D;&#x3D;&#x3D;&#x3D;&gt;十六进制数 1 1 1 1 1 1 1 1128 64 32 16 8 4 2 1一个字节八位，最大存储256个位。128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 &#x3D; 256 单位/换算1B(字节) == 8Bit(位) 1024B == 1KB(千字节) 1024KB == 1MB(兆字节) 1024MB == 1GB(吉字节) 1024GB == 1TB(太字节) 1024TB == 1PB(拍字节) 进制转换公式 二进制转八进制 三位一转 1001 1101 010 011 101 == 235 二进制转十六进制 四位一转 1001 1101 1001 1101 == 9D 十进制转N进制整数部分=&gt;除法求余 小数部分=&gt;乘法取整 待定。。。 N进制转十进制按位乘N的i次方后相加 1234561234&#x3D;&gt; 4*N^0 + 3*N^1 + 2*N^2 + 1*N^3 &#x3D;&#x3D;&#x3D;&gt;结果为十进制数值八进制157转十进制157 &#x3D;&#x3D; 7*8^0 + 5*8^1 + 1*8^2 &#x3D; 7 + 50 + 101 &#x3D;&#x3D; 111十六进制157转十进制157 &#x3D;&#x3D; 7*16^0 + 5*16^1 + 1*16^2 &#x3D;&#x3D; 343 其他进制转换 123456八进制转十六进制二进制做桥梁157 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;八进制001 101 111 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制0110 1111 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制6 F &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;十六进制 总结 除了转到十进制是各项加起来，其他进制转换是合起来。 二进制转八进制三位一取，如何合起来 123101 0115 3八进制就是53 二进制转十进制代入公式即可 1101011&#x3D;&gt; 1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 &#x3D;&#x3D; 43 &#x3D;&gt;结果为便是十进制数值 二进制转十六进制四位一取 12340010 1011 2 8+2+1 2 B十六进制就是2B 八进制转二进制三位一取 1234 6 3 44+2 2+1 4110 011 100二进制数就是110 011 100 八进制转十进制代入公式 123456346*8^2 + 3*8^1 + 4*8^0384 + 24 + 4412十进制数就是412 八进制转十六进制先转二进制再转十六进制 1234567 6 3 4 4+2 2+1 4 110 011 1000001 1001 1100 1 8+1 8+4 1 9 C十六进制就是19C 十进制转二进制除法求余 十进制转八进制除法求余 十进制转十六进制除法求余 十六进制转二进制四位一取 12345 6 D 4+2 13 4+2 8+4+10110 1101二进制数就是0110 1101 十六进制转八进制先转二进制再转八进制 12345678 6 D 4+2 13 4+2 8+4+10110 1101001 101 101 1 4+1 4+1 1 5 5八进制数就是155 十六进制转十进制代入公式 123456 6 D6*16^1 + D*16^096 + 13*16^096 + 13109十进制数就是109","categories":[],"tags":[{"name":"单位","slug":"单位","permalink":"http://example.com/tags/%E5%8D%95%E4%BD%8D/"},{"name":"进制转换","slug":"进制转换","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"}]},{"title":"C语言入门概要","date":"2021-03-01T01:55:44.747Z","path":"2021/03/01/C语言第一课/","text":"C语言第一课入门概要 [toc] 计算机发展史 世界上第一台计算机ENIAC于1946年在美国宾夕法尼亚大学诞生。 1950年第一台并行计算机，实现了计算机之父“冯诺伊曼”的两个设想： 采用二进制和存储程序，延续至今。 1958年第二代计算机诞生，增加了浮点运算。 1964年第三代计算机开始使用集成电路。软件方面出现了分时操作系统以及结构化、规模化程序设计方法。 1970年第四代计算机采用大规模集成电路。软件方面出现了数据库管理系统、网络管理系统和面向对象语言。 计算机原理用来做计算用，只能做加法运算。10 - 2转换为10 + （ - 2 ） 冯诺伊曼原理：程序和数据一样存取，一步一步取， 冯诺伊曼体系结构计算机工作原理：存储程序、程序控制。 硬件 计算机硬件的基本组成：运算器、存储器、控制器、输入输出设备。 运算器：做算术和逻辑运算。 存储器：存储数据。 控制器：各个部件按指令功能协调工作的部件。 CPU：包括运算器、控制器、寄存器等部件。 主频：CPU执行指令的频率。 外频：CPU和硬件通信的频率。 输入输出设备：向计算机输入数据和信息的设备，是计算机和用户或其他设备通信的桥梁。 计算机科学之父艾伦-麦席森-图灵 世界上第一位程序员阿达-洛芙莱斯(女) 计算机语言发展史机器语言–&gt;汇编语言–&gt;高级语言","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}]},{"title":"Hexo博客基本使用","date":"2021-02-28T04:01:07.964Z","path":"2021/02/28/Hexo博客基本使用/","text":"Hexo博客基本使用Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 [toc] 在.md文件中一定要加上头，不然hexo会编译错误-–title: Hexo博客基本使用date: 2021-02-26 19:45:15tags: 博客（这里是标签）-– Hexo博客插入图片的方法 1. 在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。 git bash安装插件：npm install https://github.com/7ym0n/hexo-asset-image –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。 用标签包裹图片，如下： 1&lt;div style&#x3D;&quot;width:70%;margin:auto&quot;&gt;&#123;% asset_img Screenshot_20210227_103343.png Markdown快捷键整合 %&#125;&lt;&#x2F;div&gt; 截断博客的方法123上文&lt;!-- more --&gt; &#x3D;&#x3D;&#x3D;&gt;把这个标签放在上下文中间就可以实现截断下文 修改主题的位置将下载的主题包解压后放到themes文件夹下 在hexo博客根目录下找到_config.yml文件 找到theme: 1theme: yilia(填写自己下载的主题名) 清理hexo博客1hexo clean 重新生成1hexo g 预览1hexo s 本地预览博客 推至远端1hexo d","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"yilia主题完善","date":"2021-02-27T23:05:09.595Z","path":"2021/02/28/yilia完善/","text":"Hexo yilia完善配置缺失模块 [toc] 在博客根目录下执行 1npm i hexo-generator-json-content --save 找到根目录下的_config.yml，不是themes文件夹下的，然后随便找一个空位，我找的位置是 1234567891011121314151617181920theme: yilia &#x2F;&#x2F;填写下面这些jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: true tags: true","categories":[],"tags":[{"name":"yilia主题配置","slug":"yilia主题配置","permalink":"http://example.com/tags/yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Typora快捷键","date":"2021-02-27T05:41:09.000Z","path":"2021/02/27/Typora使用教程/","text":"Typora使用教程简介Typora是一款轻便简洁的Markdown编辑器，支持即使渲染技术，删除了预览窗口。 目录[toc] Markdown介绍Markdown是一种轻量级标记语言，它允许人们使用纯文本格式编写文档。 Markdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式文档。 Markdown编写的文档后缀为.md、.markdown。 常用快捷键 加粗：Ctrl + B或者**两个星号**包裹 标题：Ctrl + H 插入链接：Ctrl + K 行内代码：Ctrl + Shift + K 插入图片如下： 1&lt;div style&#x3D;&quot;width:70%;margin:auto&quot;&gt;&#123;% asset_img Screenshot_20210227_103343.png Markdown快捷键整合 %&#125;&lt;&#x2F;div&gt; 撤销：Ctrl + Z 一级标题：Ctrl + 1 —&gt;以此类推 反斜杆 \\ 类似编程里的注释 引用文字\\ &gt; + 空格 + 引用的文字 此处测试引用文字效果 无序列表\\使用 * + - 都可以创建一个无序列表 AAA BBB CCC 注：* + - 这些符号在引用的时候后面都需要加上空格 列表嵌套只需要在子列表前加四个空格 有序列表使用 1. 2. 3. 创建有序列表 AAA BBB CCC 任务列表“- [ ] ”不勾选 任务一 空格！空格！空格！三处空格！ “- [X]”勾选 任务二 中括号里的x不分大小写 代码块Ctrl + Shift + K 1printf(&quot;hello word&quot;); **```** 1printf(&quot;hello word&quot;); 这是多行代码块，快捷键可以创建代码块，三个反单引号后回车也可以 hello 这是单词之类的短代码块，两个反单引号包裹代码 数学表达式当需要插入数学表达式时，用两个美元$$包裹TeX或LaTeX格式的数学公式来实现$$\\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3$$ 直接输入两个美元符号后回车，然后就可以输入数学公式了 插入表格输入| 表头1 |表头2|并回车，即可创建一个列表，快捷键Ctrl + T弹出对话框。 学号 姓名 不管哪种方式，第一行为表头，第二行为分割表头和主题部分，第三行开始每一行为一个表格行 列与列之间用管道符号|隔开 脚注百度[^1] 百度[^1] 脚注标识可以为字母数字下划线，但不支持中文，脚注内容可以为任意字符，包括中文 分割线输入***或者---再回车即可绘制一条水平线，如下： 目录（TOC）输入[toc]然后回车，即可创建一个”目录“。TOC从文档中提取所有标题，其内容自动更新。 [toc] 内部链接带标题属性的[链接1](http://baidu.com/ &quot;标题&quot;) 没有标题属性的[链接2](http://google.com) 链接1 链接2 网址Typora允许用&lt;括号括起来&gt;，把URL作为链接插入。 Typora还会自动链接标准网址。 https://www.baidu.com 图片![显示的文字](C:\\Users\\k\\Desktop\\1.png &quot;图片标题&quot;) ![显示的文字](C:\\Users\\k\\Desktop\\1.png) 直接将图片托进来自动生成链接 斜体用*单个信号*或_单下划线_可以字体倾斜。快捷键Ctrl + I 斜体 用***三个星号***可以加粗斜体 加粗斜体 删除线使用～～删除线～～，快捷键Alt + Shift + 5 删除线 下划线&lt;u&gt;下划线内容&lt;/u&gt;或快捷键Ctrl + U 下划线的内容 下标使用&lt;sub&gt;文本&lt;/sub&gt;实现 H&lt;sub&gt;2&lt;/sub&gt;O H2O 上标使用&lt;sup&gt;文本&lt;/sup&gt;实现 X&lt;sup&gt;2&lt;/sup&gt; X2 高亮==高亮== ==Very good！==","categories":[],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]}]