[{"title":"深入C语言第十二课","date":"2021-04-15T14:19:38.569Z","path":"2021/04/15/深入C语言第十二课/","text":"深入C语言第十二课指针与函数函数指针12345678910这三个一致叫类型一致，就可以将同函数组成一个函数指针的数组进行循环调用//1、参数序列一致例如：void foo(int,char,float)和void fooB(int,char,float);//它俩一致void foo(int,float,char)和void fooB(int,char,float);//它俩不一致//2、调用约定一致都为C约定或其他约定//3、返回值类型一致 12345678函数指针的定义void (_cdecl *foo)(int);void (*foo)(int);void (*foo)();void:返回值_cdecl:调用约定(int):参数序列 函数指针数组1234567891011121314151617函数指针数组定义void fooA()&#123;&#125;void fooB()&#123;&#125;void fooC()&#123;&#125;void fooD()&#123;&#125;void (*pfn[])() = &#123;fooA,fooB,fooC,fooD&#125;;调用pfn[1]();//这样就将fooB函数调用了 补充编码禁忌：严禁返回局部变量或参数变量 的 地址！！！因为局部变量或参数变量的地址处于回收状态。","categories":[],"tags":[]},{"title":"深入C语言第十一课","date":"2021-04-14T13:46:44.748Z","path":"2021/04/14/深入C语言第十一课/","text":"深入C语言第十一课宏补充123#define SET_NAME(s) #s //此处的单#号可以把数组名留下char ary[5][20] = &#123;SET_NAME(ary)&#125;;//此时调试就可以看到该数组的名字在该数组元素中 1234567891011121314151617181920212223242526272829#define SET_NAME(s) #s#define DEF_ARRAY(type,ary,nCount,size) type ary[nCount][size] = &#123;SET_NAME(ary)&#125;;int main()&#123; DEF_ARRAY(char,ary,5,20);//这里用宏直接对其进行替换&#125;//将自己创建的各种类型名放到一个数组中，用单#号留下类型名，这样可以检查类型是否相同//用宏还可以做到给它任意一个数据，它可以自己识别类型，比如给它一个小数，它自动识别为float或double，或者给它一个字符，自动识别为char#define DEF_ADD(type)\\type type##Add(type x,type y) \\&#123; \\ return x+y; \\&#125;#define CALL_ADD(type,x,y) type##Add(x,y)DEF_ADD(int);DEF_ADD(float);DEF_ADD(double);//这种用宏的方法就是现在的模板int main()&#123; int n = CALL_ADD(int,2,4); float f = CALL_ADD(float,2.0,4.0); double dbl = CALL_ADD(double,2.0,4.0); return 0;&#125;//C++不用这样，因为已经自带关键词了，这种玩宏的方法只有C可以用 指针指针概念指针有解释方式的地址。 地址没有解释方式。 123456789101112131415例如：int *p = NULL;//此处的int就是解释方式void *p = NULL;//因为此处的是void，也就是无解释方式，因此它就只是地址void *pv = NULL;int *pn = NULL;pn = pv;//这一行代码是错误的，因为类型不同，解释方式不同。此处的意思是地址赋值给指针。没有这个逻辑pv = pn;//这一行代码是对的，此处是将指针赋值给地址，因为指针是地址void *pv = 0x19ff88;//这种赋值方式不行，因为0x19ff28是整型，此处会强类型检查。int *p = NULL;*p//此处的意思是先取指针内的地址值，然后用int来解释该地址。间接访问。 指针与整型做运算123456789101112131415161718192021222324252627282930//同类型指针加法type *ptr = ...;int n = ...;ptr + n = (type *)((int)p + n*sizeof(type));//加完后是同类型指针== ptr[n] = *(ptr + n);//同类型指针减法type *ptrA = ...;type *ptrB = ...;ptrA - ptrB = ((int)ptrA - (int)ptrB) / sizeof(type);//减完后的值是常量，可以求出两个指针之间的字节数//补充int *p;++p = NULL;//前缀++是指针变量，p可以不断赋值。原因是先p自加1再代入运算。p++ = NULL;//此时会报错，因为后缀++是指针常量,p不可以不断赋值。先p代入运算再p自加1。char*p;*p++;//++先结合，然后结合*号。此时是*p指针内存储地址的+1项地址。(*p)++;//此处变成了char++。因为*p == char == 一个字节，不同类型指针在内存中存储的空间大小和类型一致char *psz = &quot;hello&quot;;//符合模式下会通过//此时会报错，因为类型不同，&quot;hello&quot;是特殊的字符串，引用的是字符型常量首地址。//而char *psz是变量指针psz[0] = &#x27;h&#x27;;//如果想要它通过可以修改为下面这个样子const char *psz = &quot;hello&quot;;//这时就将左右两边的类型一致了//或者char *psz = (char*)&quot;hello&quot;;//加强转 对可执行文件修改属性十六进制打开可执行文件，找到rdata两行半的一个字节，此处是可读可执行权限 1234567WRES1111读、写、执行、共享此处的十六进制C0转化为二进制是1010对应上面就是可读可执行,将它修改为1110，此时就增加了写的权限，对于静态区可以通过这个方法来实现写入 下面第二张图就是通过这个方式实现静态区写入","categories":[],"tags":[]},{"title":"深入C语言第十课","date":"2021-04-13T02:18:22.054Z","path":"2021/04/13/深入C语言第十课/","text":"深入C语言第十课静态变量当下面通过不断调用赋值给静态变量时，静态变量只会被赋值一次，后面的情况不会被赋值，因为静态变量是一个受语法约束的全局变量。 静态变量不参与代码编译，看汇编就会发现汇编下没有任何动作，因为它从程序开始到结束只初始化一次 该静态变量在内存中因为没有初始化，编译器便用一个标识来表示。 这是标识 框中的一行代码将静态变量的标识给重新赋值为0，这样就跳过了语法上对静态变量的赋值限制 注意！！！这只是个例，标识符位置不一定在数据后面，根据编译器不同，可能在别的地方！ 注意！！！此处标志访问设计多线程问题，不要在线程函数里使用静态局部变量，因为静态局部变量在线程函数内使用有是否初始化问题，可能标志还未翻转，其他进程就已经对它进行了多次修改 在vs2019中这个标志被存到了TLS数据块的位置，保证了线上安全 结果 演示而已，标志位不一定和数据在一块，有可能标志在数据前面 宏宏展开，编译器完成查找替换的宏被称为宏展开 在这个地方加/P,大写的P。 加了/P后只编译不链接，因为会产生.i文件而不是.obj文件，因此无法链接 用文本编译器查看.i文件就会发现里面被宏替换后的文件效果 #开头都是编译前预处理，只要是预处理都不要加;分号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//符号名称#define PI 3.14//表达式宏#define GET_AREA(r) ((r)+(r)+3.14)#define NAME_CAT(n) qls##n//##表示连接的意思，此处是将qls连接在n前面#define NAME_CAT(n) n##qls//##表示连接的意思，此处是将qls连接在n后面//当然前后一起连接也可以//语句块宏#define ShowMsg(s) printf(s);printf(&quot;\\r\\n&quot;);//兼容性宏#define for if(0)&#123;&#125;else if#define INT int#define while if//这是恶作剧宏，让程序通过不报错//说明性宏#define IN#define OUTvoid foo(IN int nCount,OUT int *pout)//这里的宏只做说明性作用&#123; &#125;//预处理宏#if 0...#endif #ifdef IN...#endif #ifndef IN...#endif #if defined(IN)...#endif #if !defined(IN)...#endif //编译选项宏//用来解决需要在不同文件里定义同一个宏的情况，在下面这个地方加了宏后，便不需要再define了// /D &quot;IN&quot;//这个/D &quot;IN&quot;在下面这个位置。在箭头的上一个输入框中定义，箭头所指的框会自动出现该宏 下面这个是编译选项组，可以自定义，比如选择专门的一个编译选项，里面放上需要加入的宏，以后用该选项就可以自动使用该选项添加的宏 1//编译器内置宏(厂商相关)//这个宏平时看不到，比如用来显示版本的宏 121:绝对路径宏2:当前行数宏 当需要定义一个函数编译成.obj给调用者使用时，宏得被调用方定义，将宏写在头文件里 12当出现重复定义时，例如：a文件包含b，b文件包含c，c文件包含a.这样的定义方式可以防止重复定义 补充12345while(a &lt; 10)//当使用某一个函数时因为内部代码过多，超过一屏，则可以在最后的&#125;后注释&#123;&#125;//end while(a &lt; 10),这里最好将函数全部复制下来注释，这是规范#pragma once//高版本有这个关键字，是告诉编译器，本文件只包含一次","categories":[],"tags":[]},{"title":"深入C语言第九课","date":"2021-04-12T02:36:43.414Z","path":"2021/04/12/深入C语言第九课/","text":"深入C语言第九课全局变量定义在所有函数以外的变量称之为全局变量 全局变量命名用g_开头 全局变量定义在所有函数以外，可以跨文件 全局变量跨文件使用时用extern声明，注意声明的时候有变量类型加变量名即可，不需要具体的内容 全局变量声明以后即可使用 1234例如：extern char g_szBuf[];//不能加下标以及赋值extern char Buf;extern void foo(); 12找到全局变量的地址，然后转到二进制文件打开后，Ctrl + G直接跳转至全局变量地址//注意！！！这种找全局变量的方式只能在VC6并且是CPP文件下才行，其他IDE需要修改一些设置才行 想要在main函数前执行代码，可以在全局变量区先执行 已初始化的全局变量和已初始化的全局变量他们的地址在一块 未初始化的全局变量和未初始化的全局变量他们的地址在一块 已初始化的全局变量内存中会提前预留空间，未初始化的全局变量不会提前预留空间 函数这是_cinit()函数，负责全局数据初始化以及C++的全局对象构造函数的调用 这是_cinit()函数中的初始化浮点处理器 第一个_initterm是初始化官方对象，例如stdin``stdout都在里面 第二个_initterm中的两个指针 _PVFV中的第一个p表示指针，第二个v表示void，第三个f表示flag型(这是个啥还没具体搞清楚)，最后一个v表示参数 函数初始化会包两层，一层包函数调用，一层包函数的赋值运算 全局化调用函数在main函数前。下面的图片显示的是定义一个全局变量，而全局变量的值又是一个函数，因此该函数的调用在main函数前 12345例如：当g_nTest = GetInt() * GetInt();如果是int n = 2;static int g_nTest = n;//会报错，这是C的问题，在c++里面被解决了 //查看栈的话就会发现它只包了一层 静态全局变量123static char g_szBuf[] = &quot;hello&quot;;//将变量锁在该文件里，别的文件无法调用，当然如果另外第二个变量取地址再用下标访问该静态变量是可以的//是一个受语法约束的变量，装载方式依旧是全局变量的形式 静态局部变量静态局部变量本质上还是今天全局，只不过不同的是静态局部限制的是不能跨函数，静态全局限制的是不能跨文件 为了可以找到局部变量，编译器会自动对其名称进行重命名，也叫名称粉碎、名称重组，只有地址是不会瞎改变的，根据地址来找是最靠谱的 12345static int stcnTest = 0x1314520;// _?stcnTest@?1??main@@9@HA上面的是静态变量名在内存中被重组后的样子在.obj文件里以二进制形式查看，一般在最后，我的VC6里面修改完要查看变化得把文件关掉重开查看才会有变化 重组后的名字中1表示层级，接在函数名后的表示参数信息 _fastcall是调用约定，它重组后的是下面黑色框中的I。 这是C约定的样子 VC6的bug浮点bug1234567891011121314//在VC6中输入下面的代码，编译没问题，一输入参数就崩。int main()&#123; float f; scanf(&quot;%f&quot;,&amp;f);&#125;//原因是早期的VC6编译器在main函数中有一个判断是否有浮点运算的过程，这个过程判断有浮点运算才初始化，否则认为无浮点运算便不初始化，因此会崩int main()&#123; float m = 0.0f;//这样运行又不会崩，因为编译器认为有浮点运算，因此对浮点初始化 float f; scanf(&quot;%f&quot;,&amp;f);&#125;//高版本编译器没有这个问题，因为不管有没有全部初始化 gotobug123456789101112131415161718192021222324//正常情况int fun()&#123; return 0;&#125;int main()&#123; fun(); return 0;&#125;//bug情况。VC6中会编译通过int fun()&#123; goto NEXT;//死循环 return 0;//想要看细节可以看汇编，会发现它是自己跳自己 NEXT: ;&#125;int main()&#123; fun(); return 0;&#125; 监视器窗口bug定义了，但监视窗口没有 原因是监视器窗口采用的是c风格的名称粉碎，只需要将CPP文件改成c就可以了 只有相同风格的名称粉碎才能找到 当用.c文件调用.cpp文件时要注意名称粉碎问题，不然可能会找不到函数名之类的情况。而.c文件却可以被.cpp文件调用，这是早期设计时的问题 补充fflush(stdin)清除缓存函数只能在低版本vs上对scanf清除 rewind(stdin)高版本清除缓存函数 可执行文件装载在内存中的位置被称为模块基址","categories":[],"tags":[]},{"title":"深入C语言第八课","date":"2021-04-08T14:59:46.184Z","path":"2021/04/08/深入C语言第八课/","text":"深入C语言第八课字符与字符串设计原则 强内聚：例如函数自己构建，自己做 低耦合：减少依赖","categories":[],"tags":[]},{"title":"深入C语言第七课","date":"2021-04-07T12:15:49.949Z","path":"2021/04/07/深入C语言第七课/","text":"深入C语言第七课二维数组多维数组是特殊的一维数组 数组的引用名是第0个元素的地址常量 多维数组取得基本数据元素需要做多次下标运算 多维数组下标运算1234567891011121314151617181920212223242526272829303132type ary[M][N] = ...;int x,y = ...;ary[x][y] 两次下标运算 ary[x] address is:(int)ary + sizeof(ary[N])*x(int)ary + sizeof(type[N])*x == (int)ary[x] //得到一维数组ary[x][y] address is:(int)ary[x] + sizeof(type)*y=(int)ary + sizeof(type[N])*x + sizeof(type)*y=(int)ary + sizeof(type)N*x + sizeof(type)*y=(int)ary + sizeof(type)(N*x + y)//优化后的结果公式int ary[3][5] = &#123; &#123;1,2,3,4,5&#125;,//在栈中最先填充 &#123;11,12,13,14,15&#125;, &#123;21,22,23,24,25&#125;&#125;printf(&quot;%p\\r\\n&quot;,&amp;ary[1][2]);printf(&quot;%p\\r\\n&quot;,(int)ary + sizeof(int[5])*1 + sizeof(int)*2);//sizeof(int[5])*1中的int[5]意义：括号内填的单个元素为一维数组，所以这样写//sizeof(int)*2中的int意义：括号内填的单个元素为一个int整型，所以这样写int x = 5,y = 8;printf(&quot;%p\\r\\n&quot;,&amp;ary[x][y]);printf(&quot;%p\\r\\n&quot;,(int)ary + sizeof(int[5])*x + sizeof(int)*y);//sizeof(int[5])*x和sizeof(int)*y都是常量//(int)ary加数组名它也是一个常量 传参数组名作为参数传递给函数时，函数内的数组名为常量(地址常量)，可以参与运算，例如ary[]作为函数参数传参，函数内可以ary++ 12[]、*、-&gt; 这三个符号有间接访问的功能间接访问的关键不在于传递的参数是不是指针，而在于有没有上面三个符号 字符串字符串有两个流派 123456789101112先报长度，后报数据=========&gt;Pascal style Pascal风格访问效率高，跳着取 先报数据，后接结束标志=====&gt;C style C风格利于实时传输 char szBuf[] = &quot;Hello&quot;;//此处有隐类型转换short int wszBuf[] = &quot;Hello&quot;;//注意！不同编码版本转化会触发强类型检查，因此会报错short int wszBuf[] = L&quot;Hello&quot;;//需要加上L这样就可以做到类型一致#include &lt;locale.h&gt;setlocale(LC_ALL,&quot;chs&quot;);//该函数用于应对不同编码环境时计算机不认识的情况","categories":[],"tags":[]},{"title":"深入C语言第六课","date":"2021-04-06T08:10:04.154Z","path":"2021/04/06/深入C语言第六课/","text":"深入C语言第六课递归递归用来解决非线性问题，效率比循环至少低一倍，因为总路线长，去了还要回来 循环用来解决线性问题 线性问题：有唯一的头和唯一的尾。 注释123456789101112131415161718&#x2F;*函数功能各个参数意义返回值意义备注或其他信息*版本和修改日期，修改人*&#x2F;&#x2F;*Maze:迷宫求解char szMaze[][25]:int x:int y:int nRow:返回值:无使用递归实现*版本和修改日期，修改人*&#x2F; 数组12345678910111213141516171819int ary[5] &#x3D; &#123;1,2,3,4,5&#125;;ary[2] &#x3D; 30;&#x2F;&#x2F;下标运算&#x2F;&#x2F;下标运算需要地址类型和类整型数组特性：连续性、一致性，不留空，不对齐，不重叠。元素类型一致。下标运算的计算法则type ary[M] &#x3D; ....;int n &#x3D; ...;ary[n] address is :(int)ary + sizeof(type)*n&#x2F;&#x2F;数组下标运算是做这个公式的运算第0个元素的地址 + sizeof(type)*n第0个元素的地址 + sizeof(int)*n第0个元素的地址 + 4*n&#x3D;&#x3D; n下标的地址&#x2F;&#x2F;这就达到了访问n下标的元素内容取出00400000的DWORD值(int)ary + sizeof(type)*n &#x3D; 0x00400000n &#x3D; (0x00400000 - (int)ary) &#x2F; sizof(type)这样就可以求出某数组元素位置的下标值 补充1234int a &#x3D; 2;int b &#x3D; 3;a + b &#x3D; 5;&#x2F;&#x2F;这个5是整型常量加减乘除取模、数学类运算、位运算得到的结果都是常量。 第四行最后第四个字节 两行半后的四字节 数组指针和指针数组","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"递归","slug":"递归","permalink":"http://example.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"深入C语言第五课","date":"2021-04-03T09:41:48.754Z","path":"2021/04/03/深入C语言第五课/","text":"深入C语言第五课四大区任何操作系统都有四大区，代码区(code)、数据区(data)、栈区(stack)、堆(heap) 代码区(code)：放二进制的可执行代码，机器码 数据区(data)：(C语言中)全局变量、静态变量、常量。 已初始化(init)： 可读写(rw)：全局变量、静态变量 只读(r)：常量 未初始化(uninit) 如果全局变量未初始化放入未初始化区中 栈区(stack)：看下面 堆区(heap)：以后说 四个属性write(写)、read(读)、execute(执行)、share(共享)。 代码区(code):可读可执行(re)。 数据区(data):未初始化区域可读可执行(rw)，初始化区域根据变量类型，四大区中写了。 栈区(stack):可读可写(rw) 堆区(heap):可读可写(rw) 栈(堆栈)调用者(caller) 被调者(callee) _cdecl：从右往左传递参数，参数通过栈传递，调用方负责清理参数空间(支持不定参，不定参指的是不固定参数的数量) _stdcall：从右往左传递参数，参数通过栈传递，被调方负责清理参数空间(不支持不定参，不定参指的是不固定参数的数量) _fastcall：从右往左传递参数，左数前两个参数通过处理器存放(寄存器),其余参数通过栈保存，被调方负责清理参数空间(不支持不定参) 按调用约定传参。 调用约定(_cdecl(C标准约定)，_fastcall(快速调用约定，微软的约定，无法跨平台，特定设备用)，_stdcall(标准调用约定，微软的操作系统上的调用约定)) 参数的传递方向 参数的存储媒介 谁负责释放参数空间(有且只有一方负责) 返回值的处理* 在栈顶保存返回地址 保存调用方的栈信息 更新栈位置（更新的操作在处理器中）到被调方的栈底处 在栈内开辟局部变量的空间 （可能有）编译选项有/Zi+/Od,则填充局部变量空间为0xcc 保存寄存器环境 执行函数体 恢复寄存器环境 释放局部变量空间 恢复栈信息到调用方 两种情况 _cdecl：取出返回地址，并按此做流程更新。抵达新地址后，由调用方清理参数。 _stdcall _fastcall：取出返回地址，并清理参数，然后按返回地址做流程更新。","categories":[],"tags":[{"name":"堆栈","slug":"堆栈","permalink":"http://example.com/tags/%E5%A0%86%E6%A0%88/"}]},{"title":"深入C语言第四课","date":"2021-04-01T13:12:06.619Z","path":"2021/04/01/深入C语言第四课/","text":"深入C语言第四课分支与循环switch函数 当数据分布均等没有优先级，不考虑优先且等值比较适用。 1234567891011121314151617181920switch(n)//在内存里相当于是一个指针数组&#123;case 10://不一定非得从1开始，因为系统会自动对最小的case做减法，变成0。10 - 10 = 0 break;//注意这个地方少了一个case 11，那么就会在11这个地方存储default的地址case 12://其他也会减10 break;case 14://顺序不影响在内存中的存储,在内存中存储的方式是从0开始递增存储 break;case 13: break;case 15: break;case 18: break;default://如果没有default时，则存储return的指针。 break;&#125;//所有中间的空出来的全部填default或return的指针。//case不可以是小数！！！ if。。。else函数手工优化效率上最多和switch对等 可以做区间判断 补充IDE标准布局","categories":[],"tags":[]},{"title":"深入C语言第三课","date":"2021-03-31T09:42:36.687Z","path":"2021/03/31/深入C语言第三课/","text":"深入C语言第三课浮点数进制转换小数十进制转二进制整数部分正常转，小数部分乘二取整。 1234567891011121314151617181920212223242526272829300.625 =====&gt;十进制的小数//注意！！！如果出现十进制0.1转二进制时会出现无限循环小数，不是公式的问题！！//根据规则转化过程0.625* 2------1.250 ======&gt;取整数部分1，在小数点后一位的位置，例如0.1的1这个位置。 0.25 ======&gt;取完整数部分1用余下的小数部分继续转化* 2------ 0.50 ======&gt;取整数部分0，在小数点后两位的位置，例如0.01的1这个位置。 0.5 ======&gt;取完整数部分0用余下的小数部分继续转化* 2------ 1.0 ======&gt;取整数部分1，在小数后三位的位置，例如0.001的1这个位置//当小数部分为0时停止转化 //原理2 1 0 -1 -2 -3===&gt;二进制的第几位1 1 0 . 1 0 1===&gt;二进制的小数 ↑↑====&gt;这是小数点整数部分 110 == 1*10^2 + 1*10^1 + 0*10^0小数部分 0.101 == 1*10^(-1) + 0*10^(-2) + 1*10^(-3)因为0.1表示10^(-1)所以假设有一个小数是0.3，那么就表示3*10^(-1);//补充一个知识点---位权对于多位数，处在某一位上的“1”所表示的数值的大小，称为该位的位权。例如十进制第2位的位权为10，第3位的位权为100；而二进制第2位的位权为2，第3位的位权为4，对于 N进制数，整数部分第 i位的位权为N^(i-1)，而小数部分第j位的位权为N^-j。 小数二进制转十进制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//如果是小数0.00101011//那么也要按照1.01011 * 10^(-3)算10111.101 =====&gt;二进制小数10111.101 == 1.0111101 * 10^4 =====&gt;小数点前必须是1当为4字节时符号位 指数位 数据位S EEEEEEEE DDDDDDDDDDDDDDDDDDDDDDD0 10000011 01111010000000000000000 //128+3=131，指数位记录的也就是正指数4。0为正数 4+127 .01111010000000000000000 =====&gt;小数部分，剩下的补0，注意！！！小数存储右边补0，和整数相反。///////上面的4为指数。127为中间0，小于127则为负的指数，大于127则为正的指数，//上面是编码 //下面是还原0 10000011 01111010000000000000000//一共32位，四个字节1.0111101//将小数部分抄下来再在前面加上1.1.0111101*10^（131-127）//根据指数位确定指数，再根据符号位确定正负。 //小数二进制转十六进制0100 0001 1011 1101 0000 0000 0000 00004 1 B D 0 0 0 000 00 BD 41//小尾方式书写//小数二进制转十进制10111.1011*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 + 1*2^(-1) + 0*2^(-2) + 1*2^(-3)=23.625 练习1：地址0013FF74内容为：00 68 45 44，小尾存储，存放的是float变量，转十进制4 4 4 5 6 8 0 00100 0100 0100 0101 0110 1000 0000 00000 10001000 100010101101000000000001.100010101101*10^（128 + 8 - 127）1.100010101101*10^（9）1100010101.101 //这是转成二进制的小数 1*2^9 + 1*2^8 + 0*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0 + 1*2^(-1) + 0*2^(-2) + 1*2^(-3)=789.625 练习2:895.75转为float类型的十六进制形式895 = 1101111111(B)895.751101111111.111.10111111111*10^90 10001000 10111111111//此时指数位应该是9，10001000换成十进制减十进制127等于90100 0100 0101 1111 1111 0000 0000 0000//因为float是四字节，所以在后面补0，小数二进制后面补04 4 5 F F 0 0 000 F0 5F 44 计算机中所有运算都会转化为加法和移位的问题12345678910111213141516171819202122232425262728乘法运算时先将十进制数转二进制数 A*10110111 A*(10000000 + 100000 + 10000 + 100 + 10 + 1)=10000000A + 100000A + 10000A + 100A + 10A + A=A&lt;&lt;8 + A&lt;&lt;5 + A&lt;&lt;4 + A&lt;&lt;1 + A//此时就变成了移位问题和加法问题除法运算时先将十进制数转为二进制数 A/C=A*C分之一//还没彻底搞懂，细节待定！！！减法运算时A - B //默认环境1字节，有00-ff一共100(这是十六进制的ff+1)个数A + (100 - B) - 100negB = 100 - B//neg是求补运算，negB表示求B的补集B + ~B = FF//任意一个二进制数加上它取反的数都为1，也就是FFB + ~B + 1 = 100~B + 1 = 100 - B//这时就将减法变成了加法A + ~B + 1 - 100 == A - B//这时只需要算A + ~B + 1的值就行了，这里的减100为进位，默认丢失，两数相加进位丢失例如：十进制98减十进制56 98 - 56=98 + (100 - 56) - 100=98 + 44 - 100=142 - 100=42//进位丢失就是将42前面的进位1丢掉便是结果。 注意：补码和求补的区别求补是运算，和加法减法一样 补码是编码方式，其中有一个步骤需要用到求补运算 补码123456789101112131415161718192021222324//当1字节时d7 d6 d5 d4 d3 d2 d1 d0//名称S D D D D D D D//S是符号位，其他是数据位当符号位是0表示正数时0 DDDDDDD//数据正常存放1 neg(DDDDDDD)//求补后存放例如十进制50500 011 0010//化二进制当-50时-501 100 1101//此时还没有加1只是取反，下一步加11 100 1110//第一位是1表示负号，后面的数取反加1 当从1字节转为4字节时500000 0000 0000 0000 0011 0010//前面补符号位0，因为是50 当-50时-501111 1111 1111 1111 1100 1110//前面补符号位1，因为是-50","categories":[],"tags":[]},{"title":"深入C语言第二课","date":"2021-03-30T11:24:07.391Z","path":"2021/03/30/深入C语言第二课/","text":"深入C语言第二课rand函数随机函数 进rand.c文件 _MT为多线程，return处为单线程，holdrand是个全局变量，该全局变量的初值为1(在文件上面)。 12345int *p;*p = 999;printf(&quot;%d\\r\\n&quot;,*p);//在debug中必崩！但在release中不一定，因为内存布局发生了变化。//必须要赋初值，或者赋错误值 变量初始化123456789int n = 0;float f = 0.0f;double dbl = 0.0;char c = &#x27;\\0&#x27;;int *p = NULL;//实际上都是0值。int *p;//如果初始化了，继续下面的代码，必定报错，不会走后面的流程。*p = 999;printf(&quot;%d\\r\\n&quot;,*p); scanf函数注意下面代码中%后面的15是限制输入的字符宽度。如果不限制会越界，另外scanf遇到空格会当做截断符。 下面的代码中%后面的[0-9]表示只接受0到9的数字。 下面的代码中%后面的[0,7,9]表示只接受0,7,9这三个数字。当继续向后获取下一个字符发现不是这三个数时，便截断，自此结束后面的获取，即使后面还有这三个数也不要了。 下面的代码中%后面的[^0]表示排除0。 延伸一下就是[^0-9]排除0到9的数字。这些属于正则表达式知识。 补充q是商，r是余数。 代入r = a - qb这个公式即可算出结果。 123456789101112int main()&#123; int i = 0; while(i &gt;= 0) &#123; printf(&quot;%08x\\r\\n&quot;,i);//它会一直加到7ffff,再加1的话就变成800000，此时就变成了负数。退出循环。 i++; &#125; system(&quot;pause&quot;); return 0;&#125;//需要注意的是因为printf干很多事，所以会耽误while循环的速度。如果将printf放在while外面，不出几秒就可以得出结果。 命名规范123456789int n,i;&#x2F;&#x2F;例如：int nName;int iName;short int w,h;&#x2F;&#x2F;例如：short int wName;short int hName;float f,flt;&#x2F;&#x2F;例如：float fName;float fltName;double d,dbl;&#x2F;&#x2F;例如：double dName;double dblName;char c,by;&#x2F;&#x2F;例如：char cName;char byName;char* psz;&#x2F;&#x2F;例如：char* pszName;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;p是指针的缩写，s表示string，z表示zero，就是以NULL结尾的stringchar sz[SIZE];&#x2F;&#x2F;例如：char szName[SIZE];s表示string，z表示zero，就是以NULL结尾的stringFILE f;&#x2F;&#x2F;例如：FILE fName;结构体 tag;&#x2F;&#x2F;例如：结构体 tagName;","categories":[],"tags":[{"name":"rand函数","slug":"rand函数","permalink":"http://example.com/tags/rand%E5%87%BD%E6%95%B0/"},{"name":"scanf函数","slug":"scanf函数","permalink":"http://example.com/tags/scanf%E5%87%BD%E6%95%B0/"},{"name":"命名规范","slug":"命名规范","permalink":"http://example.com/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"name":"各变量初始化","slug":"各变量初始化","permalink":"http://example.com/tags/%E5%90%84%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"深入C语言第一课","date":"2021-03-29T02:07:00.557Z","path":"2021/03/29/深入C语言第一课/","text":"深入C语言第一课编译器VC6.0 12345CL.EXE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;这是编译器，大小只有64kb是因为它是一个shell，它不是关键，关键是上面三个C1.DLLC1XX.DLLC2.DLL&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;这三个才是关键，负责将源代码转化为二进制 VS2015（后续版本位置类似） 编译后的文件是.obj结尾的文件 .obj文件是程序编译后的二进制文件，可以给别的语言平台使用，例如C语言编译的.obj可以给Pascal(结构化编程语言)语言使用 链接器VC6.0 1LINK.EXE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;链接器 VS2015（后续版本位置类似） 链接器链接后的文件只适用于该平台使用。例如windows系统上链接程序生成.exe文件，该文件只能在Windows上使用。 #include &lt;stdio.h&gt;首先找环境变量，根据环境变量里面的路径找文件名stdio.h,环境变量里面有多个地址，一个一个找，直到找到文件后打开复制粘贴到源代码。 尖括号默认为找系统库文件。 #include &quot;abc.bmp&quot;“ ”双引号默认为自定义文件，注意程序编译不看后缀名。例如：这里的.bmp是图片后缀名。 这里的头文件根据不同公司情况而定 xxxx.zsdll ======&gt;知识的力量(zsdll)简写 xxxx.hpp ======&gt;江湖上默认这个是C++头文件 main()的执行过程main()函数入口点在CRT0.c文件里。 vc6里的路径为 1C:\\Program Files (x86)\\Microsoft Visual Studio\\VC98\\CRT\\SRC\\CRT0.C 根据不同程序有上面四种入口。 窗口程序入口是Win开头，控制台程序入口是main开头。前面的小写w是宽字符 先获取当前操作系统的版本GetVersion()获取版本号函数 然后判断多线程环境还是单线程环境 !_heap_init(1)多线程环境初始化堆 !_heap_init(0)单线程环境初始化堆 如果是多线程环境还有初始化多线程 然后初始化IO(stdin,stdout,stderr这三个是由初始化IO得来) 再然后获得命令行 再然后获得环境变量 再然后格式化命令行 再然后格式化环境变量 再然后全局初始化 再然后获得当前进程基本环境 再后面才到main函数 main函数三个参数，标准规定main函数两个(编译器不一定按标准来)。 当return返回时 返回值做exit(mainret)参数(exit返回的是进程返回值，因为参数为main函数的返回值，所以也可以认为main函数返回值决定exit进程返回值) main函数返回值决定了exit的返回值 exit函数会调ExitProcess(mainret)（关键是调这个函数） 除此之外，还做全局变量的释放工作 补充长整型常量后面要加L 123.14 &#x3D;&#x3D;&#x3D;&#x3D;&gt;这是双精度浮点常量3.14f &#x3D;&#x3D;&#x3D;&gt;这是单精度浮点常量 可选部分 加前缀%03的0表示补零，默认右对齐，左对齐的话加-,例如：%-3 &gt;重定向符号，将左边的输出到右边 &lt;重定向符号，将右边的输出到左边 标准输出输入支持重定向(stdin,stdout)注意：stderr不支持重定向！！！ 例如程序hello中使用stdin时，可以重定向&lt;将右侧的hello.txt内容输出到hello中。 stderr不支持重定向，但可以将错误显示到屏幕，例如stderr可以在系统磁盘空间没有时将错误显示在屏幕，这样就不需要单独创建文件来写入错误信息。","categories":[],"tags":[{"name":"main函数内部","slug":"main函数内部","permalink":"http://example.com/tags/main%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8/"},{"name":"编译器和链接器","slug":"编译器和链接器","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E9%93%BE%E6%8E%A5%E5%99%A8/"}]},{"title":"文件操作","date":"2021-03-20T06:49:11.553Z","path":"2021/03/20/C语言第十五课/","text":"C语言第十五课打开文件fopen12345678FILE* fopen(const char* fileName, const char* openMode);//fileName:文件名//openMode：打开方式fopen(&quot;text.txt&quot;,&quot;r&quot;);//以只读模式打开text.txt文件，打开的文件要和程序在同一目录下fopen(&quot;F:\\\\CR40\\\\15\\\\test.txt&quot;, &quot;w&quot;);//以绝对路径的方式打开，因为\\会被当做转义字符，因此需要用两个斜杠\\\\fopen();//返回值是一个指针FILE* fp = fopen(&quot;F:\\\\CR40\\\\15\\\\test.txt&quot;, &quot;w&quot;); 打开方式文本内容（文本方式是先将字符转成ASCII码，然后以二进制存储） r 只读打开(文件必须存在) w 写(文件不存在就创建，有数据就清空) a 写(追加数据，不清除内容) r+ 读写(文件必须存在) w+ 读写(文件不存在就创建，有数据就清空) a+ 读写(追加数据，不清除内容) 二进制内容(binary) rb 只读打开(文件必须存在) wb 写(文件不存在就创建，有数据就清空) ab 写(追加数据，不清除内容) rb+ 读写(文件必须存在) wb+ 读写(文件不存在就创建，有数据就清空) ab+ 读写(追加数据，不清除内容) 关闭文件fclose12int fclose(FILE* pointerOnFile);//括号内是文件指针fclose(fp);//这样就把fp这个文件指针打开的文件关闭了 文件写入函数fwrite12345size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr是要写入的元素数组指针内容//size被写入的每个元素的大小，以字节为单位//nmemb是元素个数，每个元素的大小是size字节//stream是指向FILE对象的指针，该FILE对象指定了一个输出流。被写入的文件 1234567891011121314#include&lt;stdio.h&gt; int main ()&#123; FILE *fp; char str[] = &quot;This is runoob.com&quot;; fp = fopen( &quot;file.txt&quot; , &quot;w&quot; ); fwrite(str, sizeof(str) , 1, fp );//因为char每个元素字节为一个，所以写1 fclose(fp); return(0);&#125; 函数fputc1234int fputc(int character, FILE* pointerOnFile);//character:int型变量，表示要写入的字符。也可以直接写&#x27;A&#x27;这种形式//pointerOnFile:指向文件的指针//返回int值，写入失败返回EOF。 12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE* file = NULL; file = fopen(&quot;test.txt&quot;, &quot;w&quot;); if (file != NULL) &#123; fputc(&#x27;A&#x27;, file); // 写入字符 A fclose(file); &#125; return 0;&#125; 函数fputs1234int fputs(const char* string, FILE* pointerOnFile);//string:要写入的字符串//pointerOnFile:指向文件的指针//出错返回EOF 12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE* file = NULL; file = fopen(&quot;test.txt&quot;, &quot;w&quot;); if (file != NULL) &#123; fputs(&quot;你好，朋友。\\n最近怎么样？&quot;, file); fclose(file); &#125; return 0;&#125; 函数fprintf1int fprintf(FILE *stream, const char *format, ...)//用法和printf类似 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE* file = NULL; int age = 0; file = fopen(&quot;test.txt&quot;, &quot;w&quot;); if (file != NULL) &#123; // 询问用户的年龄 printf(&quot;您几岁了 ? &quot;); scanf(&quot;%d&quot;, &amp;age); // 写入文件 fprintf(file, &quot;使用者年龄是 %d 岁\\n&quot;, age); fclose(file); &#125; return 0;&#125; 文件读出函数fread12345size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr是被写入的指针对象。用这个指针对象来显示文件里的内容//size是读取的每一个元素的大小，以字节为单位//nmemb是元素的个数，每个元素的大小是size字节//stream是指向FILE对象的指针。要显示的文件对象 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main()&#123; FILE *fp; char c[] = &quot;This is runoob&quot;; char buffer[20]; /* 打开文件用于读写 */ fp = fopen(&quot;file.txt&quot;, &quot;w+&quot;); /* 写入数据到文件 */ fwrite(c, strlen(c) + 1, 1, fp); /* 查找文件的开头 */ fseek(fp, 0, SEEK_SET); /* 读取并显示数据 */ fread(buffer, strlen(c)+1, 1, fp); printf(&quot;%s\\n&quot;, buffer); fclose(fp); return(0);&#125; 函数fgetc读出一个字符 12int fgetc(FILE* pointerOnFile);//返回值是读到的字符，如果读取不到字符，返回EOF 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE* file = NULL; int currentCharacter = 0; file = fopen(&quot;test.txt&quot;, &quot;r&quot;); if (file != NULL) &#123; // 循环读取，每次一个字符 do &#123; currentCharacter = fgetc(file); // 读取一个字符 printf(&quot;%c&quot;, currentCharacter); // 显示读取到的字符 &#125; while (currentCharacter != EOF); // 我们继续，直到 fgetc 返回 EOF（表示“文件结束”）为止 fclose(file); &#125; return 0;&#125; 函数fgets读出一个字符串 1char* fgets(char* string, int characterNumberToRead, FILE* pointerOnFile); 123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAX_SIZE 1000 // 数组的最大尺寸 1000int main(int argc, char *argv[])&#123; FILE* file = NULL; char string[MAX_SIZE] = &quot;&quot;; // 尺寸为 MAX_SIZE 的数组，初始为空 file = fopen(&quot;test.txt&quot;, &quot;r&quot;); if (file != NULL) &#123; fgets(string, MAX_SIZE, file); // 我们读取最多 MAX_SIZE 个字符的字符串，将其存储在 string 中 printf(&quot;%s\\n&quot;, string); // 显示字符串 fclose(file); &#125; return 0;&#125; 读取整个文件内容 123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAX_SIZE 1000 // 数组的最大尺寸 1000int main(int argc, char *argv[])&#123; FILE* file = NULL; char string[MAX_SIZE] = &quot;&quot;; // 尺寸为 MAX_SIZE 的数组，初始为空 file = fopen(&quot;test.txt&quot;, &quot;r&quot;); if (file != NULL) &#123; while (fgets(string, MAX_SIZE, file) != NULL) // 我们一行一行地读取文件内容，只要不遇到文件结尾 printf(&quot;%s\\n&quot;, string); // 显示字符串 fclose(file); &#125; return 0;&#125; 函数fscanf与scanf用法类似，只是多了一个文件指针。可以从文件读取。 1int fscanf(FILE *stream, const char *format, ...) 12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE* file = NULL; int score[3] = &#123;0&#125;; // 包含 3 个最佳得分的数组 file = fopen(&quot;test.txt&quot;, &quot;r&quot;); if (file != NULL) &#123; fscanf(file, &quot;%d %d %d&quot;, &amp;score[0], &amp;score[1], &amp;score[2]); printf(&quot;最佳得分是 : %d, %d 和 %d\\n&quot;, score[0], score[1], score[2]); fclose(file); &#125; return 0;&#125; 在文件中移动 个人建议使用下面游标时最好在二进制文件里移动，因为它是按照字节来移动的！！！ 二进制文件使用方法就是创建时读写方式和文件后缀修改即可 文本文件里依旧是按字节来移动，而不是按汉字数来移动。 函数ftell告诉目前在文件中的哪个位置。tell表示“告诉” 12long ftell(FILE* pointerOnFile);//pointerOnFile是文件指针，指向当前文件。 函数fseek移动文件中的游标到指定位置。seek表示“探寻” 123456int fseek(FILE* pointerOnFile, long move, int origin);//move参数：可以是一个正整数。表明向前移动；0，表明不移动；或者负数，表明回退。//origin参数：取值为下面三个任意一个// SEEK_SET:文件开始处。SET表示“设置”// SEEK_CUR:游标当前所在位置。CUR是当前(current)的缩写// SEEK_END:文件末尾。END表示“结尾”。 12345678// 这行代码将游标放置到距离文件开始处 5 个位置的地方fseek(file, 5, SEEK_SET);// 这行代码将游标放置到距离当前位置往后 3 个位置的地方fseek(file, -3, SEEK_CUR);// 这行代码将游标放置到文件末尾fseek(file, 0, SEEK_END); 函数rewind将游标重置到文件的开始位置。rewind表示“转回” 相当于fseek来使游标回到0的位置。 1void rewind(FILE* pointerOnFile); 文件的重命名和删除(注意这两个函数不需要文件指针做参数，传文件名即可)函数rename重命名一个文件 123int rename(const char* oldName, const char* newName);//oldName是“旧名字”。newName是“新名字”。成功返回0；否则返回非零int型值 123456int main(int argc, char *argv[])&#123; rename(&quot;test.txt&quot;, &quot;renamed_test.txt&quot;); return 0;&#125; 函数remove删除一个文件 12int remove(const char* fileToRemove);&#x2F;&#x2F;fileToRemove是要删除的文件名。 remove函数慎用！它不提醒你是否确认删除文件，而是从硬盘永久删除，不进垃圾箱！！！！ 123456int main(int argc, char *argv[])&#123; remove(&quot;test.txt&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"堆和栈以及位运算","date":"2021-03-18T07:58:51.134Z","path":"2021/03/18/C语言第十四课/","text":"C语言第十四课堆动态内存调用12345678typedef struct _date&#123; int a; char b;&#125;date;date num[2];//&lt;stdlib.h&gt; and &lt;malloc.h&gt; size = malloc(sizeof(date));//放入类型类型，malloc函数会根据sizeof的数值动态给内存大小 1calloc(number,sizeof(date));//几个sizeof大小 123size = malloc(sizeof(date));realloc(size,2 * sizeof(date));//在原来的空间上申请一个更大的空间,原空间大小是size，再申请2个sizeof(date)大小的空间。//如果有相邻的就将空间给你，如果没有就找一个这么大的空间给你，原空间释放。 栈堆栈空间（栈） 位运算与&amp;运算123451 真 0假 &amp;(与) 1 &amp; 1 = 1 0 &amp; 1 = 0 1 &amp; 0 = 0 0 &amp; 0 = 01.任何位与上1结果为原本的值2.任何位与上0结果为0 或|运算123|(或) 1 | 1 = 1 0 | 1 = 1 1 | 0 = 1 0 | 0 = 01.任何位或上1结果为12.任何位或上0结果为原本的值 异或^运算123^ (异或） 按位取反 1 ^ 1 = 0 0 ^ 1 = 1 1 ^ 0 = 1 0 &amp; 0 = 01.任何位异或1取反2.任何位异或0保留不变 取反~运算12~(取反) 1 =&gt; 0 0 =&gt; 1p = ~p;//将p的每一位都取反 左移&lt;&lt;123//左移int n = 1; n = n &lt;&lt; 7; //0000 0001 =&gt; 1000 0000//将n的1向左移7位 有符号左移123char num = 0xf0;//1111 0000 =&gt; 1110 0000//左移一位，缺的补零，移出的丢掉num &lt;&lt;= 1;printf(&quot;num: %02x\\n&quot;,num); 右移&gt;&gt;有符号右移，高位补符号位（最高位是0补0，是1补1） 1110 0000 ==&gt; 1111 0000123num = 0x7f;//0111 1111num &gt;&gt;= 2;//0111 1111 =&gt; 0001 1111 printf(&quot;num:%02x\\n&quot;,num);","categories":[],"tags":[{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"与","slug":"与","permalink":"http://example.com/tags/%E4%B8%8E/"},{"name":"或","slug":"或","permalink":"http://example.com/tags/%E6%88%96/"},{"name":"异或","slug":"异或","permalink":"http://example.com/tags/%E5%BC%82%E6%88%96/"},{"name":"动态内存调用","slug":"动态内存调用","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E8%B0%83%E7%94%A8/"},{"name":"左移<<","slug":"左移","permalink":"http://example.com/tags/%E5%B7%A6%E7%A7%BB/"},{"name":"右移>>","slug":"右移","permalink":"http://example.com/tags/%E5%8F%B3%E7%A7%BB/"}]},{"title":"结构体、共用体、枚举","date":"2021-03-17T12:41:10.198Z","path":"2021/03/17/C语言第十三课/","text":"C语言第十三课结构体123456789101112typedef struct _date //struct是为了说明这是一个结构体类型，_date是结构体名，可以不写&#123; int a; //结构体内部可以写多个不同类型的数据 char b; //结构体的大小等于所有变量大小之和，但一般会不准，因为有系统优化对齐的原因。 float c[5];&#125;date;//告诉编译器有date这个结构体数据类型date num[2]; //date类型结构体数组//结构体指针date *p = &amp;num[0];//定义一个date类型的指针，将date类型的数组num[0]赋给指针//指针访问成员p-&gt;a = 10;//将值10赋给指针p指向date类型的num[0]下的int a变量 typedef 告诉编译器重新定义一个数据类型，别名。 函数参数尽量用指针：1、节省空间。2、指针修改形参影响实参。 结构体嵌套123456789struct tag_1&#123; struct tag_1 A; //这是错误的方式！！！！！ int value;&#125;;struct tag_1&#123; struct tag_1 *A;//这才是正确的方式！！！，需要用指针。 int value;&#125; 1234567891011121314151617181920212223242526&#x2F;&#x2F;使用typedef时typedef struct&#123; int value; &#x2F;&#x2F;这是错误的方式！！！！ NODE *link;&#125;NODE;&#x2F;&#x2F;下面这三种才是正确的方式！！！！typedef struct tag_1&#123; int value; struct tag_1 *link; &#125; NODE;&#x2F;&#x2F;这个时候NODE类型没有创造出来，所以不能用！！！struct tag_2;typedef struct tag_2 NODE;&#x2F;&#x2F;这个时候NODE类型被创造出来了，所以可以用struct tag_2&#123; int value; NODE *link; &#125;;struct tag_3&#123; int value; struct tag_3 *link; &#125;;typedef struct tag_3 NODE; 共用体1234567typedef union _date //union是为了说明这是个共用体类型，_date是共用体名，可以不写&#123; int a; //共用体内部可以写多个不同类型的数据 char b; //共用体的大小等于最大的类型变量大小，&#125;date;//告诉编译器有date这个共用体数据类型date num[2]; //date类型共用体数组 枚举123456789101112131415enum COLOR //enum是为了说明这是枚举类型，COLOR枚举名&#123; RED, //默认从0开始，RED == 0; GREEN, //GREEN == 1; BLUE //BLUE == 2;依次类推。&#125;;enum COLOR //enum是为了说明这是枚举类型，COLOR枚举名&#123; RED = 3, GREEN = 2, BLUE = 1, BLACK //此时BLACK的值为2，因为它根据前一个的值递增，但这就会出现bug，因为GREEN的值也是2。&#125;;","categories":[],"tags":[{"name":"结构体","slug":"结构体","permalink":"http://example.com/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"共用体","slug":"共用体","permalink":"http://example.com/tags/%E5%85%B1%E7%94%A8%E4%BD%93/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"常用函数","date":"2021-03-16T15:08:24.268Z","path":"2021/03/16/C语言第十二课/","text":"C语言第十二课常用库函数随机函数123#include &lt;time.h&gt;srand((unsigned)time(NULL));//获取随机数种子int type = rand() % 3;//随机0-2这三个数 判断是否有按键输入函数12#include &lt;conio.h&gt;_kbhit()//返回0","categories":[],"tags":[{"name":"常用库函数","slug":"常用库函数","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0/"}]},{"title":"指针","date":"2021-03-15T08:44:43.646Z","path":"2021/03/15/C语言第十一课/","text":"C语言第十一课宏(补充)宏只做简单的替换，任何函数或C语言关键词或者其他什么的不讲究，不会出现替换if...else就报错的情况，当替换复杂的判断或循环函数时，用\\斜杠来连接下一行。 1234#define OUTPUT for(int i = 0;i &lt; 10;i++)\\&#123;\\ printf(&quot;hello\\r\\n&quot;);\\&#125; //==============&gt;最后一行建议不加\\，如果加，就要空一行 12345#define OUTPUT for(int i = 0;i &lt; 10;i++)\\&#123;\\ printf(&quot;hello\\r\\n&quot;);\\&#125;\\ //==============&gt;最后一行建议不加\\，如果加，就要空一行 //==============&gt;空这一行。 C语言会将\\的下一行作为宏要替换的内容。 字符和字符串的转义问题 字符转义 123char ch = 1; //显示大王char ch = &#x27;\\x1&#x27;; //显示大王。表示十六进制的1。ASCII码第1位是大王图标。这就是字符的转义\\===&gt;这个斜杠是为了告诉计算机后面的是转义字符。x1中的x是十六进制的意思 字符串转义 123char ary[] = &#123;&quot;hello\\x1&quot;&#125;;//将&#x27;\\x1&#x27;作为字符串的一部分写在里面//注意这里的&#x27;x1&#x27;不要写十进制，如果要显示&#x27;A&#x27;，它的十六进制是65，写&#x27;\\65&#x27;的话，计算机只会将&#x27;\\6&#x27;计算在内，&#x27;5&#x27;会当做普通字符输出char ary[] = &#123;&quot;hello\\65&quot;&#125;;=====&gt;输出的结果是&quot;hello5&quot; 总结，在字符串中使用转义字符的时候需要加\\，并且后面要用十六进制的ASCII码，即使是输出\\也要找到ASCII表里\\的ASCII码。 \\就是用来告诉计算机后面的是转义字符。这是语法规定。 变量的生命周期及作用域变量分类局部变量生命周期以函数单位，进入函数生命周期开始，调用返回生命周期结束。 租房子 节省空间，通过参数传递需要的数量 1234567int main()&#123; for(int i = 0;i &lt; 10;i++)//这里定义的i变量只能在for函数内使用，出了这个函数就被释放了 &#123; &#125;&#125; 全局变量生命周期以程序为单位，进入程序运行生命周期开始，程序结束生命周期结束 买房子 占用空间，传递数据方便，容易出bug 12345int i = 0;//这个变量因为在函数外定义，直到程序结束才会被释放，这种变量就是全局变量int main()&#123;&#125; 变量的作用域程序作用域、函数作用域、块作用域块作用域 12345678910&#123; //两个大括号之间就是一个块作用域 extern int block1;//向前声明，可以重复写向前声明 //通过extern这个关键词来告诉计算机已经定义了block1这个变量，如果没有这个变量却依旧用这个骗计算机，计算机会报错 //原因是计算机会扫描确定是否真的有这个变量 block1 = 0; int block1 = 1; block1 = 2;&#125; 函数作用域 1234void Fun()//在函数体内部这块区域叫函数作用域&#123; //在这里面定义的变量只能在这个函数内使用，出了这个函数，这个变量就被释放了。&#125; 程序作用域 123456int block1 = 0;//从程序运行开始到程序运行结束才被释放，这就会程序作用域//全局变量的作用域就是程序作用域int main()&#123; int block2 = 0;//这个变量的作用域基本上也可以算程序作用域，因为它在main函数内，却在main函数里面其他的函数外&#125; 指针&amp;这是取址符，用来取变量地址。 *这是取值符，用来取指针变量所指向的地址的内容。 定义指针先用类型说明符来说明，再用指针的*符号加变量名 12int *p = NULL;//NULL表示空，也等于0 将变量地址传递给指针 123456789int num1 = 5;int *p = NULL;p = &amp;num1;//这种方式和下面这种方式一样int num2 = 8;int *q = &amp;num2;int num3[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;p = num3;//这里没有加&amp;是因为数组名就是地址 注意：如果用void *p来接受指针这可以接受各种类型的指针，这就增加了指针的通用性。 指针大小为4个字节(地址) void *任意类型 12345678910111213141516void Fun(void *p, int count)//这里用void*指针接受任意类型指针&#123; int *q = (int*)p;//这里将传过来的并且用void*指针接受的指针地址，强转为int*指针。 //这样转不会出现越界问题 for (int i = 0; i &lt; count; i++) &#123; printf(&quot;%d&quot;, (int*)q[i]); &#125;&#125;int main(int argc, char *argv[])&#123; int a[5] = &#123; 1, 2, 3, 4, 5&#125;; char b[5] = &#123; &quot;hello&quot; &#125;; Fun(a, 5);&#125; 这里补充一个函数，memcpy(目标指针，源指针，大小)这个库函数是用来拷贝内存的 1234567void *memcpy( void *dest, const void *src, size_t count );//细节看文档void Fun(void *p,int size)&#123; int num[5] = &#123;0&#125;; memcpy(num,p,size);//拷贝内存,比如p为数组指针，size就是p数组的大小，num就是要拷贝到的目标指针。这个目标指针也得和p一个类型一个大小，这样才能接受。&#125; 多级指针多级指针在函数中的使用 123456789101112131415161718192021void cs(int *p)//此为一级指针，用来接收变量的地址&#123; (*p)++;//此处的*p表示的是指针变量里面的地址所指向的变量内容 printf(&quot;%d\\n&quot;, *p);&#125;void csp(int **p)//此为二级指针，用来接收一级指针的地址&#123; (**p)++;//此处的**p表示的是二级指针变量里面的一级指针变量里面的地址所指向的变量内容 printf(&quot;%d\\n&quot;, **p);&#125;int main(int argc, char *argv[])&#123; int age = 10; int *ap = &amp;age; cs(&amp;age);//此处传递的是变量的地址，用一级指针来接收 csp(&amp;ap);//此处传递的是一级指针的地址，用二级指针来接收 system(&quot;pause&quot;); return 0;&#125; 一级指针用来接收变量的地址 二级指针用来接收一级指针变量的地址 多级指针依此类推 12345678910111213int age = 10;int *p = NULL;int **q =NULL;p = &amp;age ----&gt;用指针p接收变量age的地址q = &amp;p ----&gt;用二级指针q来接收一级指针p的地址*p ----&gt;这可以访问变量age下的数据内容*p == &amp;age;它俩相对应 **q ----&gt;这可以访问变量age下的数据内容**q == &amp;age;它俩相对应 注意！！！1234567891011121314void Fun1(void *p, int count)&#123; for (int i = 0; i &lt; count; i++) &#123; printf(&quot;%d&quot;, ((int*)p)[i]);//可以对形参直接操作，但要注意加括号！！！ &#125;&#125;int main(int argc, char *argv[])&#123; int a[5] = &#123; 1, 2, 3, 4, 5&#125;; char b[5] = &#123; &quot;hello&quot; &#125;; Fun1(a, 5);&#125;","categories":[],"tags":[{"name":"宏","slug":"宏","permalink":"http://example.com/tags/%E5%AE%8F/"},{"name":"变量","slug":"变量","permalink":"http://example.com/tags/%E5%8F%98%E9%87%8F/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"},{"name":"转义问题","slug":"转义问题","permalink":"http://example.com/tags/%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98/"}]},{"title":"预处理","date":"2021-03-13T02:05:54.012Z","path":"2021/03/13/C语言第十课/","text":"C语言第十课编码(补充)123//GBK 41 41 C3 E3 00 &quot;AA你&quot; //英文问号：? 中文问号：？//UNICODE 41 00 41 00 60 4F 00 00 &quot;AA你&quot;//UNICODE编码两个字节0结尾，每个字符用两个字节表示 GBK编码的函数只能显示GBK编码的参数 12char s1[] = &#123;&quot;AA你&quot;&#125;;printf(&quot;%s\\n&quot;,s1); Unicode编码只能显示Unicode编码参数 12wchar_t s1[] = &#123;L&quot;AA你&quot;&#125;;wprintf(L&quot;%s\\n&quot;,s1); 如果代码是Unicode，文件也是Unicode，但在调试的时候依旧是乱码，那是因为终端不是Unicode。 常用字符串函数(补充)fflush(stdin)只能清空字符串缓存，不能清空字符缓存。 scanf函数与putchar用时会将空格作为下一个元素输出。如果和printf用时，空格会作为格式而不是字符输出。 getchar()函数是用来获取一个字符，从输入里获取(比如终端输入，一般指从键盘输入) 1getchar(); 12345678910111213141516char a[10] = &#123; &quot;\\0&quot; &#125;; char b[10] = &#123; &quot;\\0&quot; &#125;; printf(&quot;输入第一串字符串\\r\\n&quot;); scanf(&quot;%s&quot;, &amp;a); //如果此时输入的字符串中有空格，则不会有下一个scanf输入，//而是将空格后的字符串作为第二串字符输出 fflush(stdin);//这个可以用来清空字符串缓存 printf(&quot;输入第二串字符串\\r\\n&quot;); scanf(&quot;%s&quot;, &amp;b); printf(&quot;%s\\r\\n&quot;, a); printf(&quot;%s\\r\\n&quot;, b);//printf输出有一个问题就是不会将字符串中空格作为字符输出，而是将它作为截断 函数fgetc(stdin(文件指针))函数返回值是读到的字符，如果不能读到字符，那会返回EOF 1int fgetc(FILE *stream);//因为是get，所以括号内填stdin(标准输入) 函数fgets(目标字符数组名，字符数量，stdin(文件指针))stdin位置表示获取的字符串源（stdin表示从键盘输入） 每次读一个字符串，最多读一行，遇到第一个\\n就会结束读取 fgets()这个函数会将空格作为字符而不是截断 12char a[10];fgets(a,10,stdin); stdin是标准输入 stdout是标准输出 stderr是标准错误 函数fputc(源字符，目标(文件指针))12char a;fputc(a,stdout);//因为是put，所以括号内填stdout(标准输出) 函数fputs(源字符，目标(文件指针))12char a[11] = &#123;&quot;hello word&quot;&#125;;//这里要多一个元素给&#x27;\\0&#x27;不然fputs会因为找不到&#x27;\\0&#x27;而越界fputs(a,stdout); 字符串函数例子所有的宽字符用法一样，只不过注意输入输出的格式包括字符串本身都得是Unicode，不然要么报错，要么乱码，要么不显示。 函数strcpy、strncpy、wcscpy、wcsncpy使用例子1234567891011char s1[260] = &#123;&quot;hello word你好&quot;&#125;;char s2[260];//字符串拷贝fgets(s2,260,stdin); //输入也要控制大小strcpy(s1,s2); //s2拷贝到S1，如果s1不够大，就会越界。strncpy(s1,s2,3); //指定拷贝字符长度，此处是拷贝三个字符 注意：只拷贝，不补0s1[3] = &quot;\\0&quot;; //手动补0 ！！！需要手动补0！！！！printf(&quot;s1:%s\\n&quot;,s1);return 0; 函数strcat、strncat、wcscat、wcsncat使用例子123456789101112char s1[260];char s2[260];//拼接字符串scanf(&quot;%s&quot;,s2); //输入一个字符串到s2strcpy(s1,s2); //将s2拷贝到s1strcat(s1,&quot;hello&quot;); //将hello拼接到s1后面 拼接会自动补0 //！！！注意：拼接的s1一定要初始化，不能一个&#x27;\\0&#x27;都没有 ！！！strncat(s1,&quot;hello&quot;,2); //指定拼接字符长度，此处是拷贝两个字符 printf(&quot;s1:%s\\n&quot;,s1);return 0; 函数strlen、wcslen使用例子123456char s1[260] = &#123;&quot;hello word&quot;&#125;;char s2[260];//求字符串长度int len = strlen(s1); //不包含&#x27;\\0&#x27;printf(&quot;s1 len:%s\\n&quot;,len); return 0; 函数strcmp、wcscmp使用例子12345678910111213141516171819//字符串比较 相等 大于 小于scanf(&quot;%259s&quot;,s1);scanf(&quot;%259s&quot;,s2);int result = strcmp(s1,s2); //比较两个字符串的ASCII码大小，从第一个字符开始比较，如果相等，比较下一个字符，//遇到不相等的判断ASCII码数值哪个大，左边的大(s1 &gt; s2)，返回差值(差值一定大于0)，右边的大(s1 &lt; s2),返回差值(差值一定小于0)if(result == 0) //大于返回0&#123; printf(&quot;s1相等s2\\r\\n&quot;); &#125;else if(result &lt; 0) //小于返回-1&#123; printf(&quot;s1小于s2\\r\\n&quot;);&#125;else&#123; printf(&quot;s1大于s2\\r\\n&quot;);&#125;return 0; 函数strlwr、wcslwr使用例子1234//转换小写scanf(&quot;%259s&quot;,s1);strlwr(s1); //只判断&#x27;A-Z&#x27; &#x27;a-z&#x27;其他字符不判断printf(&quot;s1:%s\\n&quot;,s1); 函数strupr、wcsupr使用例子1234//转换大写scanf(&quot;%259s&quot;,s1);strupr(s1); //只判断&#x27;A-Z&#x27; &#x27;a-z&#x27;其他字符不判断printf(&quot;s1:%s\\n&quot;,s1); 函数strstr、wcsstr使用例子1234567891011//子串（一个大的字符串里面有没有小的字符串）are you ok？ youchar s2[260];fgets(s2,260,stdin); //注意不要用scanf，不然字符串空格会当做截断if(strstr(s1,&quot;you&quot;) == 0)&#123; printf(&quot;没有you字符串\\r\\n&quot;);&#125;else&#123; printf(&quot;找到：%s\\n&quot;,strstr(s1,&quot;you&quot;)); //输出结果是you ok，后面的字符串全部输出&#125; 宽字符(补充)用下面这个函数告诉计算机，下面的代码是宽字符代码。 1setlocale(LC_ALL,&quot;chinese&quot;); 下面的是printf通用版，微软用这类函数来实现GBK和Unicode之间自动转换。方便程序员使用。 1_tprintf();//当遇到Unicode编码时自动转为Unicode版本，否则默认GBK版本。 预处理无参宏做简单的查找替换工作 1234//定义一个宏#define MAP_SIZE 8 //宏名大写，为了和程序内的变量区分//为了增加代码的维护性 有参宏12345678#define MY_ADD(a,b) a+b//有参宏相对于函数而言虽然效率高，但维护性低，成本高(占用空间大)//如果宏是一个数组，那么就容易占用大量的资源//因为宏它只做简单的替换工作，如果在做算术运算的时候因为优先级问题，可能会导致出错，而且不容易发现printf(&quot;%d\\n&quot;,MY_ADD);//如果a为3，b为&quot;hello&quot;printf(&quot;%d\\n&quot;,3 + &quot;hello&quot;);//因为宏只是简单的进行替换工作也就可能导致替换的是字符，但编译却通过，这就很难发现问题所在","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"常用字符串函数","slug":"常用字符串函数","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"},{"name":"预处理","slug":"预处理","permalink":"http://example.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"}]},{"title":"字符串","date":"2021-03-11T02:53:36.528Z","path":"2021/03/11/C语言第九课/","text":"C语言第九课（接第六课）C语言标准常用的编译器有MSVC、GCC、CLANG。 现在的C标准有C89、C99、C11、C17、C23 标准的不同比如用C89的VC6里面定义变量必须再最前面定义 123456789101112131415161718192021222324252627282930313233343536373839//VC里面（用的是C89）int main()&#123; int a = 0; ===============&gt;定义变量必须在前面 for(a = 0;a &lt; 10;a++) &#123; //..... &#125; for(int b = 0;b &lt; 10;b++)====&gt;这里定义编译就无法通过 &#123; //..... &#125;&#125;//想要在VC里面后面定义需要一个小技巧，就是加一个作用域int main()&#123; int a = 0; for(a = 0;a &lt; 10;a++) &#123; //..... &#125; &#123;================&gt;加上这个作用域就可以在后面定义了 int b; ======&gt;此时就可以编译通过 &#125;&#125;//VS2013int main()&#123; int a = 0; for(a = 0;a &lt; 10;a++) &#123; //..... &#125; for(int b = 0;b &lt; 10;b++)====&gt;这里定义编译正常通过 &#123; //..... &#125;&#125; 最早的是C89。C17修复了C11的一些bug。C23目前还不清楚有哪些编译器使用，以后可能会有吧。 另外就是，C标准更新很慢，不像别的，包括C++。 查看C标准的网站是：https://en.cppreference.com/w/ 编译器和C标准不一定相同 编译器和vs这种集成开发环境是两个东西，虽然编译器是根据C标准来写的，但不同的编译器作者写的编译器依旧有不同。比如微软写的MSVC编译器里面不允许在定义数组的时候用变量来表示数组下标。 12int count = 10;int ary[count] = &#123;0&#125;;===========&gt;//这种定义数组的方法C标准允许，但微软不允许，微软给出的解释就是容易出现bug或漏洞。 通过stdint.h这个头文件来固定变量大小，这样就可以使代码在不同编译器环境下依旧可以使用，实现跨版本跨平台使用。 ASCII编码表一个字节有8位，一般用7位表示，第八位是符号位。 也就是可以表示0~127个数。 不同的国家和公司写自己的ASCII扩展这就导致了在不同的系统上显示不同的效果。 后来为了解决例如汉字等别的语言问题，就提出了多字节字符集(MBCS)，多字节版本一般指国标GBKxxx 中国做了一个标准GB2312 。后面扩展的就叫GBKXXX 两个字符表示一个汉字。 为了解决不同国家需要不同的字符表，微软做了一个·Code Page·，这个代码页几乎包含了所有国家的字符代码。需要时选择自己国家的代码即可。 后面又出现了万国编码：Unicode编码。 Unicode字符集包含所有国家的字符代码。 但Unicode字符集有不好的地方，就是将所有国家的字符都用两个字节表示一个字符，例如中国的汉字，两个字符表示一个汉字，包括英文也是。对于英文这种只需要一个字符就可以表示，却在Unicode里用两个表示，这样极大的浪费了空间。 现在用的最多的是UTF-8编码 宽字节就是用Unicode编码显示的字符。 注意：代码所用的字符编码要和文件字符编码一直，不然会出现乱码。 字符串一连串的字符数组就是字符串， Pascal字符串：先在前面表示字符串长度，后面接字符串内容。 C语言里不是这样，为了让计算机知道字符串结尾的位置，会在后面自动补一个0。 如果是用宽字符（Unicode）来写，会在后面自动补两个0。 12char string1[] = &#123;&quot;hello&quot;&#125;;===========&gt;后面自动补一个0wchar_t string2[5] = &#123;L&quot;hello&quot;&#125;;======&gt;这个wchar_t和L表示Unicode编码。后面自动补两个0","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C标准","slug":"C标准","permalink":"http://example.com/tags/C%E6%A0%87%E5%87%86/"},{"name":"cppreference.com","slug":"cppreference-com","permalink":"http://example.com/tags/cppreference-com/"},{"name":"宽字符","slug":"宽字符","permalink":"http://example.com/tags/%E5%AE%BD%E5%AD%97%E7%AC%A6/"},{"name":"编译器","slug":"编译器","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"ASCII编码表","slug":"ASCII编码表","permalink":"http://example.com/tags/ASCII%E7%BC%96%E7%A0%81%E8%A1%A8/"}]},{"title":"数组","date":"2021-03-08T02:37:30.136Z","path":"2021/03/08/C语言第六课/","text":"C语言第六课数组数组的由来、定义及初始化 数组的由来 数组是用来存储多个（有限）相同类型数据的集合，组成数组的各个变量称为数组元素，数组元素也是一种变量。为了区分数组的各个元素，给数组进行了编号，也称为下标。 数组定义 数组的定义：数组类型说明符 数组名[数组元素个数]，数组元素个数只能是常量或常量表达式。 数组元素的引用方式：数组名[下标]。 数组初始化 12int Array[5] = &#123;1,2,3,4,5&#125;;int Array[5] = &#123;0&#125;; 数组的传参 数组传参 例如： 1234567891011void fun(int anArray[]) //anArray[]这个数组是临时创建的数组变量，不是下面的数组变量，变量名可以不同&#123; //... int n = 0;&#125;void main()&#123; int anArray[5] = &#123;1,2,3,4,5&#125;; fun(anArray);//传递数组首地址 fun(&amp;anArray[2]);//传递下标为2的元素的地址&#125; 冒泡、选择排序和查找 冒泡排序 两个相邻的元素依次比较，如果从小到大排序，第一个值如果比第二个值大则进行交换，以此类推。最大值则会依次沉入数组最后面，最小值则会慢慢排到数组最前面。如果从大到小排序，条件相反，第一个值如果比第二个值小则进行交换。 1234567891011121314int anArray[6] = &#123;8,5,4,2,6,7&#125;; //5,8,4,2,6,7 //5,4,8,2,6,7 //5,4,2,8,6,7 //5,4,2,6,8,7 //5,4,2,6,7,8 //4,5,2,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //4,2,5,6,7,8 //2,4,5,6,7,8 //冒泡排序就是这样，anArray[i]与anArray[i + 1]向下依次比较，//大的值放在右侧，小的值放在左侧，依次下去。 1234567891011121314151617int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;;int temp = 0, num = 0;num = sizeof(anArray) / sizeof(int);printf(&quot;%d&quot;, num);for (int i = 0; i &lt; num - 1; i++) &#123; for (int j = 0; j &lt; num - 1; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; 选择排序 两个相邻的值进行比较，如果从小到大排序，如果第一个值比第二个值大，则记录较小值的下标，第二次比较，较小值和后续的值进行比较，始终记录较小值的下标，一轮比较完毕，记录的较小值和下标为0的元素进行交换，第二轮则和下标为1的元素交换。依次类推。 1234567891011int anArray[6] = &#123;8,5,4,2,6,7&#125;; //2,5,4,8,6,7 //2,4,5,8,6,7 //2,4,5,8,6,7 //2,4,5,6,8,7 //2,4,5,6,7,8 //选择排序就是这样，默认anArray[0]为最小值，//后面依次用anArray[0]这个变量的值与后面别的下标变量的值进行比较，//如果中间出现比默认的变量值小，则将它倆进行交换，//这样始终保证默认的最小下标变量都是真正拥有最小值的变量，//此时一轮结束，下一轮时将默认变量改为anArray[i + 1]，然后继续向后比较交换。 123456789101112131415161718192021222324int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;;int temp = 0, num = 0;num = sizeof(anArray) / sizeof(int);printf(&quot;%d&quot;, num);int Max = 0; for (int i = 0; i &lt; num - 1; i++) &#123; Max = i; //默认的最大变量为第一项0 for (int j = i; j &lt; num; j++) &#123; if (anArray[Max] &lt; anArray[j + 1])//用默认的最大变量的值比较下一项变量的值 &#123; Max = j + 1; //将最大的变量的下标赋给Max &#125; if (j == num - 1) //确认一轮都比较完毕 &#123; int temp = 0; //开始进行交换 temp = anArray[Max]; anArray[Max] = anArray[i]; anArray[i] = temp; &#125; &#125; &#125; 二分查找法 二分查找也叫折半查找，折半查找要求线性且顺序存储结构。 记录最小值的下标为左值，记录最大值的下标为右值，最小值的下标加上最大值的下标除以2得到中间值下标，如果中间值比查找值大则右值下标更新为中间值下标-1，如果中间值比查找值小则左值下标更新为中间值下标+1。如果中间值和查找值相等则表示找到了，否则依次类推，直到找完也找不到为止，当左值等于右值时，所有元素查找完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192首先需要数组内的所有元素值按从大到小或从小到大排列好，然后才能使用二分查找法 int anArray[10] = &#123; 26, 73, 48, 42, 95, 16, 80, 27, 12, 34 &#125;; int temp = 0, num = 0; num = sizeof(anArray) / sizeof(int); printf(&quot;%d&quot;, num); //冒泡排序，简单点的 for (int i = 0; i &lt; num - 1; i++) &#123; for (int j = 0; j &lt; num - 1; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; //冒泡排序，稍微复杂点的 for (int i = 1; i &lt; num; i++) &#123; for (int j = 0; j &lt; num - i; j++) &#123; if (anArray[j] &gt; anArray[j + 1]) &#123; temp = anArray[j]; anArray[j] = anArray[j + 1]; anArray[j + 1] = temp; &#125; &#125; &#125; //下面是二分查找法 int Max = 0; int Min = 0; int Mid = 0; int Find = 0; printf(&quot;输入要查找的值\\r\\n&quot;); scanf(&quot;%d&quot;, &amp;Find); Max = num; Min = 0; //第一种二分法 for (int i = 0; i &lt; (Min + Max) / 2; i++) &#123; Mid = (Max + Min) / 2; if (anArray[Min] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (anArray[Max] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (anArray[Mid] == Find) &#123; printf(&quot;找到了\\r\\n&quot;); &#125; else if (Max == Min + 1 &amp;&amp; (anArray[Max] != Find || anArray[Min] != Find)) &#123; printf(&quot;你要查找的数不存在\\r\\n&quot;); break; &#125; else if (anArray[Mid] &gt; Find) &#123; Max = Mid - 1; &#125; else if (anArray[Mid] &lt; Find) &#123; Min = Mid + 1; &#125; &#125; //第二种二分法 while (Min &lt;= Max) &#123; Mid = (Max + Min) / 2; if (anArray[Mid] &gt; Find) &#123; Max = Mid - 1; &#125; else if (anArray[Mid] &lt; Find) &#123; Min = Mid + 1; &#125; if (anArray[Mid] == Find) &#123; printf(&quot;你要找的%d在下标为%d的数组元素内\\r\\n&quot;, Find, Mid); &#125; else if (Min == Max &amp;&amp; (Mid != Find) || Min &gt; Max) &#123; printf(&quot;你输入的数不存在\\r\\n&quot;); &#125; &#125; 二维数组的定义及初始化 以数组为数组元素的数组，数组的数组。二维数组又称矩阵 12array[3][5] = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125;&#125;;数组名 行 列 = 初始化数组。。。 当一维数组元素过多，并且元素之间有集合关系时可以用二维数组的方式存储，不仅易于维护，而且定位起来也容易很多。 12345array[3][5] = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125; =======&gt;注意最后可以加逗号，但仅限于高版本的编译器，VC就不能加&#125; 二维数组在内存中的存储和一维一样，依旧是连续存储，只是给程序员看的时候更加方便。 在用函数封装二维数组时，形参一定要有列数，但可以不用它。这是为了让编译器通过。 1234void RemoveRoom(char RoomAry[][3],int nRow,int nCol)========&gt;这里的3是为了让编译器通过，实际的行列用单独的变量来传&#123; //....&#125;","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"冒泡","slug":"冒泡","permalink":"http://example.com/tags/%E5%86%92%E6%B3%A1/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"函数","date":"2021-03-05T01:55:36.687Z","path":"2021/03/05/C语言第五课/","text":"C语言第五课函数函数的由来早期编写代码的时候人们发现只有遇到跳转指令之后才会跳转到目的指令处继续执行。所有代码都是按照将要执行的顺序排列，人们发现这样写代码非常费劲且容易出错，因为经常编写同样的代码导致工作量大幅度增加还浪费空间。为了节省空间和提高工作效率，于是想出了将经常使用的功能性代码提出来单独封装，并留出接口和外界通信。被封装的代码就是函数。 优点节省空间，对代码编写者阅读性大大提高，可维护性就变强了。 缺点性能慢，用时间换空间。在调用函数的时候，不如函数在main里面来的快，因为这中间的过程对计算机来说做了备份等工作。自然时间上就花了更多。 主函数、库函数、自定义函数主函数主函数是可执行程序的入口函数。当操作系统加载可执行程序到内存中，并且为可执行程序开辟进程空间后，系统调用的可执行程序内的第一个函数。 main()函数是C语言中的主函数，一个C程序有且仅有一个main()函数。 注意：其实真正的函数入口不是main()，只不过main()函数在用户界面看时是入口而已，系统内部不是。 库函数库函数是指把一些常用的函数单独封装到库文件/头文件里供人调用。调用时要用#include&lt;文件名.h&gt;包含调用函数所在的库文件/头文件 自定义函数自定义函数是指用户自己按需要编写的函数。调用时需要用#include“文件名.h”包含调用函数所在的头文件。 函数的定义等基本语法 函数的定义 返回值 函数名（参数类型 参数1，参数类型 参数2） 括号内可以不传参数，根据需要选择是否传参。 另外如果没有返回值可选择void这种类型 函数声明 1int MyFun(int nNum1,int nNum2); 函数实现 1234int MyFun(int nNum1,int nNum2)&#123; ...//代码&#125; 形参和实参 形参：定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。 实参：调用时传递给函数的参数，实参可以是常量，变量，表达式，函数等，在进行函数调用时，实参必须具有确定值。 实参传递给形参的数值是拷贝过去的值，不会影响到原参数。 想要实现自定义函数和主函数文件分开保存可以 1、新建一个包含自定义函数代码实现功能的.c源文件，这个文件里写自定义函数的实现过程。 2、新建一个包含自定义函数声明代码的.h头文件，这个文件里写自定义函数的函数声明。 3、在有主函数main()的.c源文件里用#include “文件名.h”包含上面这个自定义函数声明代码的.h头文件名。 这样自定义函数的实现代码就和主函数分开了，需要转移到别的主函数文件时，只需要将自定义函数的.c和.h两个文件加入即可。 注意！！！1234567891011121314void Fun1(void *p, int count)&#123; for (int i = 0; i &lt; count; i++) &#123; printf(&quot;%d&quot;, ((int*)p)[i]);//可以对形参直接操作，但要注意加括号！！！ &#125;&#125;int main(int argc, char *argv[])&#123; int a[5] = &#123; 1, 2, 3, 4, 5&#125;; char b[5] = &#123; &quot;hello&quot; &#125;; Fun1(a, 5);&#125; 命名 命名 为了统一编码风格及提高代码可读性，所以约定对变量名、函数名等采用统一风格的命名。 匈牙利命名法 微软采用的一种编码时命名规范，其基本原则： 12变量名&#x3D;属性+类型+对象描述 int nNumber &#x3D; 0; 对象的名称要求有明确的含义。据说这种命名法是一位匈牙利程序员发明的。 驼峰命名法 大驼峰 1int MyFun &#x3D; 0; &#x3D;&#x3D;&#x3D;&gt;第一个单词首字母大写，后一个单词首字母大写 小驼峰 1int myFun &#x3D; 0; &#x3D;&#x3D;&#x3D;&gt;第一个单词首字母小写，后一个单词首字母大写 递归 函数直接或间接调用函数本身，则该函数被称为递归函数。 123456789void MyFun()&#123; //... if(...) &#123; MyFun(); &#125; //...&#125; 1234567891011121314151617181920212223242526272829303132333435363738递归的运用比如目录的结构就是。​&#96;&#96;&#96;c#include &lt;stdio.h&gt;int MyAddFun(int);int mian()&#123; int nRet &#x3D; 0; nRet &#x3D; MyAddFun(5); &#x3D;&#x3D;&#x3D;&#x3D;&gt;调用函数并将结果存放到变量nRet里面 printf(&quot;%d\\r\\n&quot;,nRet);&#125;int MyAddFun(int nNum)&#123; int Temp &#x3D; 0; &#x3D;&#x3D;&#x3D;&#x3D;&gt;用来存放递归结果 if(nNum &#x3D;&#x3D; 1) &#123; return 1; &#x3D;&#x3D;&#x3D;&#x3D;&gt;给递归一个结束的返回值 &#125; Temp &#x3D; nNum + MyAddFun(nNum - 1); &#x3D;&#x3D;&#x3D;&gt;递归核心，实现不断自我调用 return Temp;&#125;&#x2F;&#x2F; 5 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + 2 + MyAddFun(nNum - 1)&#x2F;&#x2F; 5 + 4 + 3 + 2 + 1 &#x3D;&#x3D;&#x3D;&gt;由于此时MyAddFun(nNum - 1)中(nNum - 1)结果为1，触发if判断执行return 1。&#x2F;&#x2F; MyAddFun（nNum - 1）&#x3D;&#x3D; 1；&#x2F;&#x2F;再往后一步一步往回走，结果就出来了。&#x2F;&#x2F;MyAddFun(5)&#x2F;&#x2F;5 + MyAddFun(4)&#x2F;&#x2F;4 + MyAddFun(3)&#x2F;&#x2F;3 + MyAddFun(2)&#x2F;&#x2F;2 + MyAddFun(1)&#x2F;&#x2F;1 补充在调试代码的时候，将变量放到监视窗口后，可以通过在变量前加上&amp;取地址符获取该变量在内存中的位置。通过这种方法查看内存数据。 123456int nNumber &#x3D; 10;&amp;nNumber &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;假定nNumber在内存中的地址为0X0019FF28因为是int型占四个字节所以它在内存中的数据为 0 A 0 0 0 0 0 0读法是顺序是 7-&gt;8 5-&gt;6 3-&gt;4 1-&gt;2十进制的10在内存中以十六进制A显示","categories":[],"tags":[{"name":"递归","slug":"递归","permalink":"http://example.com/tags/%E9%80%92%E5%BD%92/"},{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"},{"name":"命名法","slug":"命名法","permalink":"http://example.com/tags/%E5%91%BD%E5%90%8D%E6%B3%95/"}]},{"title":"分支与循环","date":"2021-03-04T14:52:03.230Z","path":"2021/03/04/C语音第四课/","text":"C语言第四课分支与循环运算符 siezeof 运算符 sizeof 算术运算符 1+ - * &#x2F; % ++ -- 关系运算符 123&#x3D;&#x3D; 与 !&#x3D; 等于 和 不等于&gt; 与 &lt; 大于 和 小于&gt;&#x3D;与&lt;&#x3D; 大于等于 和 小于等于 逻辑运算符 1&amp;&amp; 与 || 与 ! 逻辑与 和 逻辑或 和 逻辑非 条件运算符 1?:三元运算符 if…else分支结构12345678if(表达式) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;判断是否成立&#123; 语句一 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;成立时执行这里的语句&#125;else&#123; 语句二 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;不成立时执行这里的语句&#125; ​ switch…case分支结构- switch(开关语句)常和case、break、default一起用。实现多重分支 12345678910111213switch(整形表达式) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;整形表达式里的数值决定跳转到下面的数值几语句&#123; case 数值1: 语句1; break; case 数值2: 语句2; break; default: 语句n; break; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;跳出switch &#125; for、while、do…while循环结构- for循环由循环体和判断条件两个部分组成 12345678for(表达式1;条件;表达式2)&#123; 循环体语句&#125;for(int i &#x3D; 0; i &lt; length ; i++)&#123; ....;&#125; 执行过程： - 第一步：执行表达式1 - 第二步：判断条件 - 第三步：条件成立则执行语句和表达式2 - 第四步：重复执行二、三步 直到条件不成立结束循环。 while循环，满足条件时进入循环，当条件不满足时，跳出循环。 1234while(条件)&#123; 语句;&#125; 执行过程： 第一步：判断条件 第二步：条件成立则执行语句 第三步：重复执行一、二步 ​ 直到条件不成立结束循环。","categories":[],"tags":[{"name":"循环结构","slug":"循环结构","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"},{"name":"运算符","slug":"运算符","permalink":"http://example.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"输入输出、数据类型","date":"2021-03-03T02:12:54.185Z","path":"2021/03/03/C语言第三课/","text":"C语言第三课C语言简史 1950年欧美计算机学家合力推出了ALGOL算法语言 1958年ACM小组（美国计算机协会）和联邦德国的应用数学和力学协会（GAMM）在苏黎世把他们关于算法表示法的建议综合为一种编程语言，命名为IAL，后改为AIGOL58。 1960年图灵奖获得者艾伦佩利（Alan J.Perlis）发表了“算法语言Algol 60报告”，确定了程序设计语言ALGOL 60。 1963年英国剑桥大学推出了基于ALGOL 60的高级语言CPL语言。 1967年英国剑桥大学对CPL语言做了简化，推出了BCPL语言。 1970年美国贝尔实验室的肯-汤普森（Ken Thompson）以BCPL语言为基础推出了B语言（取BCPL的第一个字母）。并用B语言编写了第一个UNIX操作系统。 1972年贝尔实验室的丹尼斯-里奇（D.M.Ritchie）在B语言的基础上设计出了C语言。丹尼斯-里奇（D.M.Ritchie）和肯-汤普森（Ken Thompson）用C语言重写了UNIX系统。 IDEIDE集成开发环境，用于提供程序开发环境的应用程序。一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。 创建第一个程序stdio===&gt;standard input &amp; output===&gt;标准输入输出 1234567#include &lt;stdio.h&gt;int main(int argc,char* argv[])&#123; printf(&quot;hello word!&quot;); return 0;&#125; Main函数C语言的入口函数main任何C语言程序只能有一个main函数，被称为主函数。 main函数的参数C语言标准中，main的参数有两个，一个十int类型的argc，一个是char*数组的argv。它们对应的是命令行传来的命令行传来的命令行参数。windows命令行通过echo &amp;errorLeveI%命令可以获取到return返回值。 argc该变量是用来统计argv数组里参数的数量。 MSDN、输入输出 MSDN 微软提供的一种信息服务 介绍各种编程技巧 printf 格式化输出函数，向标准输出设备按规定格式输出。 函数原型 1int printf(const char *format[,argument]...); scanf 从标准输入流中读取格式化数据。 函数原型 1int scanf(const char *format[,argument]...); 数据类型 数据类型 byte/char、short、int、long、longlong、float、double、signed、unsigned 1字节、2字节、4字节、4字节、8字节、4字节、8字节。 int和long的区别 早期的操作系统是16位，int用2字节表示，long用4字节表示。 发展到32位操作系统，int用4字节表示，与long相同。 格式化说明符","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://example.com/tags/IDE/"},{"name":"数据类型","slug":"数据类型","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"进制","date":"2021-03-02T02:02:00.610Z","path":"2021/03/02/C语言第二课/","text":"C语言第二课进制 [toc] 二进制（0～1）进位规则：逢二进一。 00=&gt;01=&gt;10=&gt;11=&gt;…… 三个二进制数可以表示一个八进制数。四个二进制数可以表示一个十六进制数。另外，一个字节是8bit位，这就是为什么计算机用十六进制数表示数据。 12010 101 &#x3D;&#x3D;&#x3D;&gt;二进制数，三位可以表示一个八进制数 2 4+1 &#x3D;&#x3D;&#x3D;&gt;八进制数25 二进制数在代码中加0b，例如0b10。 八进制（0～7）进位规则：逢八进一。 八进制加0,是零，不是O，例如010； 十进制（0～7）进位规则：逢十进一。 0=&gt;1=&gt;2=&gt;3=&gt;……=&gt;06=&gt;07=&gt;10=&gt;11=&gt;…… 十六进制（0～F）进位规则：01=&gt;02=&gt; …… =&gt;09=&gt;0A=&gt;0B=&gt; …… =&gt;0F=&gt;10…… 十六进制0xA。 借位规则：二进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当2，变成020，现在的个位为0，依旧不够减1，继续借，012，个位的2够减1，那么012 - 1 = 011，所以100 - 1 = 011。 借位规则：八进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当8，变成080，现在的个位为0，依旧不够减1，继续借，078，个位的8够减1，那么078 - 1 = 077，所以100 - 1 = 077。 借位规则：十进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当10，变成0A（这里的10用十进制A表示）0，现在的个位为0，依旧不够减1，继续借，09A，个位的A够减1，那么09A - 1 = 099，所以100 - 1 = 099。 借位规则：十六进制时，100 - 1 =&gt; 100的个位不够减1向前借1位，借1当16，变成0G（这里的16用十七进制G表示）0，现在的个位为0，依旧不够减1，继续借，0FG，个位的G够减1，那么0FG - 1 = 0FF，所以100 - 1 = 0FF。 规律总结12345678910111213141111 &#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制数8421 &#x3D;&#x3D;&#x3D;&#x3D;&gt;1000 &#x3D; 8 , 100 &#x3D; 4 ， 10 &#x3D; 2 ， 1 &#x3D; 1。8 + 4 + 2 + 1 &#x3D;15 &#x3D;&#x3D;&#x3D;&gt;这是二进制1111表示为十进制时候的数值。通过上面这个可以发现四位的二进制数刚好可以表示一个十六进制个位数：1 + 2 + 4 + 8 &#x3D;&gt; 15例如：1 1 1 1 116 8 4 2 1 2^4 + 2^3 + 2^2 + 2^1 + 2^0 &#x3D;31 &#x3D;&#x3D;&#x3D;&gt;这个二进制11111表示为十进制时候的数值。1111 1111 &#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制数 F F &#x3D;&#x3D;&#x3D;&#x3D;&gt;十六进制数 1 1 1 1 1 1 1 1128 64 32 16 8 4 2 1一个字节八位，最大存储256个位。128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 &#x3D; 256 单位/换算1B(字节) == 8Bit(位) 1024B == 1KB(千字节) 1024KB == 1MB(兆字节) 1024MB == 1GB(吉字节) 1024GB == 1TB(太字节) 1024TB == 1PB(拍字节) 进制转换公式 二进制转八进制 三位一转 1001 1101 010 011 101 == 235 二进制转十六进制 四位一转 1001 1101 1001 1101 == 9D 十进制转N进制整数部分=&gt;除法求余 小数部分=&gt;乘法取整 待定。。。 N进制转十进制按位乘N的i次方后相加 1234561234&#x3D;&gt; 4*N^0 + 3*N^1 + 2*N^2 + 1*N^3 &#x3D;&#x3D;&#x3D;&gt;结果为十进制数值八进制157转十进制157 &#x3D;&#x3D; 7*8^0 + 5*8^1 + 1*8^2 &#x3D; 7 + 50 + 101 &#x3D;&#x3D; 111十六进制157转十进制157 &#x3D;&#x3D; 7*16^0 + 5*16^1 + 1*16^2 &#x3D;&#x3D; 343 其他进制转换 123456八进制转十六进制二进制做桥梁157 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;八进制001 101 111 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制0110 1111 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;二进制6 F &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;十六进制 总结 除了转到十进制是各项加起来，其他进制转换是合起来。 二进制转八进制三位一取，如何合起来 123101 0115 3八进制就是53 二进制转十进制代入公式即可 1101011&#x3D;&gt; 1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 &#x3D;&#x3D; 43 &#x3D;&gt;结果为便是十进制数值 二进制转十六进制四位一取 12340010 1011 2 8+2+1 2 B十六进制就是2B 八进制转二进制三位一取 1234 6 3 44+2 2+1 4110 011 100二进制数就是110 011 100 八进制转十进制代入公式 123456346*8^2 + 3*8^1 + 4*8^0384 + 24 + 4412十进制数就是412 八进制转十六进制先转二进制再转十六进制 1234567 6 3 4 4+2 2+1 4 110 011 1000001 1001 1100 1 8+1 8+4 1 9 C十六进制就是19C 十进制转二进制除法求余 十进制转八进制除法求余 十进制转十六进制除法求余 十六进制转二进制四位一取 12345 6 D 4+2 13 4+2 8+4+10110 1101二进制数就是0110 1101 十六进制转八进制先转二进制再转八进制 12345678 6 D 4+2 13 4+2 8+4+10110 1101001 101 101 1 4+1 4+1 1 5 5八进制数就是155 十六进制转十进制代入公式 123456 6 D6*16^1 + D*16^096 + 13*16^096 + 13109十进制数就是109","categories":[],"tags":[{"name":"单位","slug":"单位","permalink":"http://example.com/tags/%E5%8D%95%E4%BD%8D/"},{"name":"进制转换","slug":"进制转换","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"}]},{"title":"C语言入门概要","date":"2021-03-01T01:55:44.747Z","path":"2021/03/01/C语言第一课/","text":"C语言第一课入门概要 [toc] 计算机发展史 世界上第一台计算机ENIAC于1946年在美国宾夕法尼亚大学诞生。 1950年第一台并行计算机，实现了计算机之父“冯诺伊曼”的两个设想： 采用二进制和存储程序，延续至今。 1958年第二代计算机诞生，增加了浮点运算。 1964年第三代计算机开始使用集成电路。软件方面出现了分时操作系统以及结构化、规模化程序设计方法。 1970年第四代计算机采用大规模集成电路。软件方面出现了数据库管理系统、网络管理系统和面向对象语言。 计算机原理用来做计算用，只能做加法运算。10 - 2转换为10 + （ - 2 ） 冯诺伊曼原理：程序和数据一样存取，一步一步取， 冯诺伊曼体系结构计算机工作原理：存储程序、程序控制。 硬件 计算机硬件的基本组成：运算器、存储器、控制器、输入输出设备。 运算器：做算术和逻辑运算。 存储器：存储数据。 控制器：各个部件按指令功能协调工作的部件。 CPU：包括运算器、控制器、寄存器等部件。 主频：CPU执行指令的频率。 外频：CPU和硬件通信的频率。 输入输出设备：向计算机输入数据和信息的设备，是计算机和用户或其他设备通信的桥梁。 计算机科学之父艾伦-麦席森-图灵 世界上第一位程序员阿达-洛芙莱斯(女) 计算机语言发展史机器语言–&gt;汇编语言–&gt;高级语言","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}]},{"title":"Hexo博客基本使用","date":"2021-02-28T04:01:07.964Z","path":"2021/02/28/Hexo博客基本使用/","text":"Hexo博客基本使用Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 [toc] 在.md文件中一定要加上头，不然hexo会编译错误-–title: Hexo博客基本使用date: 2021-02-26 19:45:15tags: 博客（这里是标签）-– Hexo博客插入图片的方法 1. 在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。 git bash安装插件：npm install https://github.com/7ym0n/hexo-asset-image –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。 用标签包裹图片，如下： 1&lt;div style&#x3D;&quot;width:70%;margin:auto&quot;&gt;&#123;% asset_img Screenshot_20210227_103343.png Markdown快捷键整合 %&#125;&lt;&#x2F;div&gt; 截断博客的方法123上文&lt;!-- more --&gt; &#x3D;&#x3D;&#x3D;&gt;把这个标签放在上下文中间就可以实现截断下文 修改主题的位置将下载的主题包解压后放到themes文件夹下 在hexo博客根目录下找到_config.yml文件 找到theme: 1theme: yilia(填写自己下载的主题名) 清理hexo博客1hexo clean 重新生成1hexo g 预览1hexo s 本地预览博客 推至远端1hexo d Hexo博客小图标1网站被收藏后显示的小图标如何设置 常用的是ico图标尺寸为32*32 可以选择默认的名字favicon.ico 将favicon.ico图标放到themes/yilia/source/img文件夹下 找到hexo/themes/yilia/layout/head.ejs,修改下面一段代码为 123&lt;% if (theme.favicon)&#123; %&gt; &lt;link rel=&quot;icon&quot; href=&quot;/img/favicon.ico&quot;&gt; &lt;% &#125; %&gt; 然后部署即可","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"yilia主题完善","date":"2021-02-27T23:05:09.595Z","path":"2021/02/28/yilia完善/","text":"Hexo yilia完善配置缺失模块 [toc] 在博客根目录下执行 1npm i hexo-generator-json-content --save 找到根目录下的_config.yml，不是themes文件夹下的，然后随便找一个空位，我找的位置是 1234567891011121314151617181920theme: yilia &#x2F;&#x2F;填写下面这些jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: true tags: true","categories":[],"tags":[{"name":"yilia主题配置","slug":"yilia主题配置","permalink":"http://example.com/tags/yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Typora快捷键","date":"2021-02-27T05:41:09.000Z","path":"2021/02/27/Typora使用教程/","text":"Typora使用教程简介Typora是一款轻便简洁的Markdown编辑器，支持即使渲染技术，删除了预览窗口。 目录[toc] Markdown介绍Markdown是一种轻量级标记语言，它允许人们使用纯文本格式编写文档。 Markdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式文档。 Markdown编写的文档后缀为.md、.markdown。 常用快捷键 加粗：Ctrl + B或者**两个星号**包裹 标题：Ctrl + H 插入链接：Ctrl + K 行内代码：Ctrl + Shift + K 插入图片如下： 1&lt;div style&#x3D;&quot;width:70%;margin:auto&quot;&gt;&#123;% asset_img Screenshot_20210227_103343.png Markdown快捷键整合 %&#125;&lt;&#x2F;div&gt; 撤销：Ctrl + Z 一级标题：Ctrl + 1 —&gt;以此类推 反斜杆 \\ 类似编程里的注释 引用文字\\ &gt; + 空格 + 引用的文字 此处测试引用文字效果 无序列表\\使用 * + - 都可以创建一个无序列表 AAA BBB CCC 注：* + - 这些符号在引用的时候后面都需要加上空格 列表嵌套只需要在子列表前加四个空格 有序列表使用 1. 2. 3. 创建有序列表 AAA BBB CCC 任务列表“- [ ] ”不勾选 任务一 空格！空格！空格！三处空格！ “- [X]”勾选 任务二 中括号里的x不分大小写 代码块Ctrl + Shift + K 1printf(&quot;hello word&quot;); **```** 1printf(&quot;hello word&quot;); 这是多行代码块，快捷键可以创建代码块，三个反单引号后回车也可以 hello 这是单词之类的短代码块，两个反单引号包裹代码 数学表达式当需要插入数学表达式时，用两个美元$$包裹TeX或LaTeX格式的数学公式来实现$$\\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3$$ 直接输入两个美元符号后回车，然后就可以输入数学公式了 插入表格输入| 表头1 |表头2|并回车，即可创建一个列表，快捷键Ctrl + T弹出对话框。 学号 姓名 不管哪种方式，第一行为表头，第二行为分割表头和主题部分，第三行开始每一行为一个表格行 列与列之间用管道符号|隔开 脚注百度[^1] 百度[^1] 脚注标识可以为字母数字下划线，但不支持中文，脚注内容可以为任意字符，包括中文 分割线输入***或者---再回车即可绘制一条水平线，如下： 目录（TOC）输入[toc]然后回车，即可创建一个”目录“。TOC从文档中提取所有标题，其内容自动更新。 [toc] 内部链接带标题属性的[链接1](http://baidu.com/ &quot;标题&quot;) 没有标题属性的[链接2](http://google.com) 链接1 链接2 网址Typora允许用&lt;括号括起来&gt;，把URL作为链接插入。 Typora还会自动链接标准网址。 https://www.baidu.com 图片![显示的文字](C:\\Users\\k\\Desktop\\1.png &quot;图片标题&quot;) ![显示的文字](C:\\Users\\k\\Desktop\\1.png) 直接将图片托进来自动生成链接 斜体用*单个信号*或_单下划线_可以字体倾斜。快捷键Ctrl + I 斜体 用***三个星号***可以加粗斜体 加粗斜体 删除线使用～～删除线～～，快捷键Alt + Shift + 5 删除线 下划线&lt;u&gt;下划线内容&lt;/u&gt;或快捷键Ctrl + U 下划线的内容 下标使用&lt;sub&gt;文本&lt;/sub&gt;实现 H&lt;sub&gt;2&lt;/sub&gt;O H2O 上标使用&lt;sup&gt;文本&lt;/sup&gt;实现 X&lt;sup&gt;2&lt;/sup&gt; X2 高亮==高亮== ==Very good！==","categories":[],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]}]